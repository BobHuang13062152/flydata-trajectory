<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>🛫 航班軌跡分析 - 真實數據演示</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);
            color: #fff;
        }
        
        .header {
            background: rgba(0,0,0,0.3);
            padding: 15px 20px;
            text-align: center;
        }
        
        .container {
            display: flex;
            height: calc(100vh - 70px);
        }
        
        .sidebar {
            width: 300px;
            background: rgba(255,255,255,0.1);
            padding: 20px;
            overflow-y: auto;
            backdrop-filter: blur(10px);
        }
        
        .map-container {
            flex: 1;
            position: relative;
        }
        
        #map {
            width: 100%;
            height: 100%;
        }
        
        .status {
            position: absolute;
            bottom: 20px;
            right: 20px;
            background: rgba(0,0,0,0.8);
            padding: 10px;
            border-radius: 10px;
            font-size: 14px;
            z-index: 1000;
            max-width: 300px;
        }
        
        button {
            width: 100%;
            padding: 10px;
            margin: 5px 0;
            border: none;
            border-radius: 5px;
            background: #42a5f5;
            color: white;
            cursor: pointer;
            font-size: 14px;
        }
        
        button:hover {
            background: #1e88e5;
        }
        
        .flight-count-control {
            background: rgba(255,255,255,0.1);
            padding: 15px;
            border-radius: 8px;
            margin: 10px 0;
        }
        
        input[type="range"] {
            width: 100%;
            margin: 10px 0;
        }
        
        .quick-buttons {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 5px;
            margin-top: 10px;
        }
        
        .quick-buttons button {
            font-size: 10px;
            padding: 5px;
            margin: 1px;
        }
        
        /* 小型演算法視窗 */
        .algorithm-modal {
            display: none;
            position: fixed;
            z-index: 3000;
            right: 20px;
            top: 50%;
            transform: translateY(-50%);
            width: 280px;
            background: linear-gradient(135deg, #1e3c72, #2a5298);
            border-radius: 10px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.5);
            border: 2px solid rgba(255,255,255,0.2);
        }
        
        .algorithm-header {
            padding: 15px;
            border-bottom: 1px solid rgba(255,255,255,0.1);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .algorithm-header h3 {
            color: #64b5f6;
            font-size: 16px;
        }
        
        .close-btn {
            background: none;
            border: none;
            color: white;
            font-size: 20px;
            cursor: pointer;
            padding: 0;
            width: auto;
        }
        
        /* 新增：增強功能樣式（學習 MATLAB 界面設計） */
        .enhancement-section {
            margin-top: 20px;
            padding-top: 15px;
            border-top: 1px solid rgba(255,255,255,0.1);
        }
        
        .enhancement-controls {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }
        
        .enhancement-item {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 8px;
            border-radius: 8px;
            background: rgba(255,255,255,0.05);
        }
        
        .enhancement-info {
            flex: 1;
        }
        
        .enhancement-name {
            font-weight: 600;
            color: #64b5f6;
            font-size: 14px;
        }
        
        .enhancement-desc {
            font-size: 12px;
            color: rgba(255,255,255,0.7);
            margin-top: 2px;
        }
        
        /* 切換開關樣式 */
        .switch {
            position: relative;
            display: inline-block;
            width: 44px;
            height: 24px;
        }
        
        .switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }
        
        .slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: rgba(255,255,255,0.2);
            transition: .3s;
            border-radius: 24px;
        }
        
        .slider:before {
            position: absolute;
            content: "";
            height: 18px;
            width: 18px;
            left: 3px;
            bottom: 3px;
            background-color: white;
            transition: .3s;
            border-radius: 50%;
        }
        
        input:checked + .slider {
            background-color: #64b5f6;
        }
        
        input:checked + .slider:before {
            transform: translateX(20px);
        }
        
        /* 優化按鈕樣式 */
        .optimization-btn {
            background: linear-gradient(135deg, #ff6b6b, #ee5a5a);
            border: none;
            color: white;
            padding: 8px 16px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 12px;
            font-weight: 600;
            transition: all 0.3s;
            width: 100%;
        }
        
        .optimization-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(255,107,107,0.3);
        }
        
        .optimization-controls {
            display: flex;
            flex-direction: column;
            gap: 6px;
        }
        
        .algorithm-list {
            padding: 15px;
            max-height: 300px;
            overflow-y: auto;
        }
        
        .algorithm-item {
            background: rgba(255,255,255,0.1);
            margin: 8px 0;
            padding: 10px;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.3s;
            border: 1px solid transparent;
        }
        
        .algorithm-item:hover {
            background: rgba(66,165,245,0.3);
            border-color: #42a5f5;
        }
        
        .algorithm-item.selected {
            background: rgba(76,175,80,0.3);
            border-color: #4caf50;
        }
        
        .algorithm-name {
            font-weight: bold;
            font-size: 13px;
            color: #81c784;
        }
        
        .algorithm-accuracy {
            font-size: 11px;
            opacity: 0.8;
            margin-top: 3px;
        }
        
        .algorithm-controls {
            padding: 15px;
            border-top: 1px solid rgba(255,255,255,0.1);
        }
        
        .algorithm-controls button {
            margin: 2px 0;
            font-size: 12px;
            padding: 8px;
        }
        
        .predict-btn { background: #4caf50; }
        .clear-btn { background: #f44336; }
        .compare-btn { background: #ff9800; }

    /* 進度條 UI（支援多任務，主要進度置頂大條，其餘小條堆疊） */
    .progress-container {
            position: absolute;
            bottom: 70px;
            right: 20px;
            width: 300px;
            background: rgba(0,0,0,0.8);
            padding: 10px;
            border-radius: 10px;
            z-index: 1001;
        }
    .progress-item { margin-top: 8px; }
    .progress-item:first-child { margin-top: 0; }
    .pi-header { display: flex; justify-content: space-between; align-items: center; font-size: 12px; color: #fff; opacity: .9; margin-bottom: 4px; }
    .pi-label { font-weight: 600; }
    .pi-meta { opacity: .9; }
    .pi-bar { width: 100%; background: rgba(255,255,255,0.12); border-radius: 6px; overflow: hidden; }
    .pi-fill { height: 100%; width: 0%; background: linear-gradient(90deg, #42a5f5, #64b5f6); transition: width .3s ease; }
    .progress-item.primary .pi-bar { height: 12px; }
    .progress-item.secondary .pi-bar { height: 6px; opacity: 0.95; }
    .pi-fill.indeterminate { width: 30%; animation: indet 1.2s infinite ease-in-out; }
        @keyframes indet {
            0% { margin-left: 0%; }
            50% { margin-left: 70%; }
            100% { margin-left: 0%; }
        }
    .progress-secondary-wrap { margin-top: 8px; max-height: 180px; overflow-y: auto; }
    </style>
</head>
<body>
    <div class="header">
        <h1>🛫 民航機軌跡預測分析系統</h1>
        <p>📊 航班軌跡數量:157313筆 | 🎯 多種演算法預測</p>
    </div>
    
    <div class="container">
        <div class="sidebar">
            <h2>🎛️ 控制面板</h2>
            
            <div class="flight-count-control">
                <h3>✈️ 航班數量</h3>
                <p>當前: <span id="flightCountDisplay">50</span></p>
                <input type="range" id="flightCountSlider" min="5" max="200000" value="50" step="5">
                
                <div class="quick-buttons">
                    <button onclick="setFlightCount(100)">100</button>
                    <button onclick="setFlightCount(1000)">1K</button>
                    <button onclick="setFlightCount(10000)">10K</button>
                    <button onclick="setFlightCount(50000)">50K</button>
                    <button onclick="setFlightCount(150000)">150K</button>
                    <button onclick="setFlightCount(157313)">ALL</button>
                </div>
            </div>
            
            <button onclick="loadFlightData()">📂 載入航班數據</button>
            <button onclick="showAllFlights()">🗺️ 顯示航線</button>
            <button onclick="hideAllFlights()">🚫 隱藏航線</button>
            <button onclick="testBackend()">🔧 測試後端</button>
            <button onclick="openAlgorithmModal()" style="background: #4caf50; font-weight: bold;">🎯 多演算法預測</button>

            <div class="enhancement-section">
                <h3>🚀 增強功能</h3>
                <div class="enhancement-controls">
                    <div class="enhancement-item">
                        <label class="switch">
                            <input type="checkbox" id="fastMode" checked>
                            <span class="slider"></span>
                        </label>
                        <div class="enhancement-info">
                            <div class="enhancement-name">⚡ Fast Mode</div>
                            <div class="enhancement-desc">加速分析（降採樣/子序列/步幅）</div>
                        </div>
                    </div>
                    <!-- LSTM 手動控制：僅在按鈕觸發時執行，不自動執行 -->
                    <div class="enhancement-item">
                        <label class="switch" title="啟用 LSTM 手動模式">
                            <input type="checkbox" id="enableLSTM">
                            <span class="slider"></span>
                        </label>
                        <div class="enhancement-info">
                            <div class="enhancement-name">🧠 LSTM 手動</div>
                            <div class="enhancement-desc">不自動；僅按下方按鈕時執行</div>
                        </div>
                    </div>
                    <div class="lstm-controls" style="margin: 6px 0 10px 44px;">
                        <div style="display:flex; align-items:center; gap:8px; margin-bottom:6px;">
                            <label for="lstmHorizon" style="font-size:12px; opacity:.85;">步數</label>
                            <input type="range" id="lstmHorizon" min="1" max="300" step="5" value="80" style="flex:1;">
                            <span id="lstmHorizonDisplay" style="width:42px; text-align:right; font-size:12px; opacity:.9;">80</span>
                            <label class="switch" title="自動決定步數">
                                <input type="checkbox" id="lstmAutoHorizon" checked>
                                <span class="slider"></span>
                            </label>
                            <span style="font-size:12px; opacity:.85;">自動</span>
                        </div>
                        <button class="optimization-btn" onclick="runLSTMNow()">▶ 執行 LSTM 預測</button>
                    </div>
                    <div class="optimization-controls">
                        <button class="optimization-btn" onclick="runBayesianOptimization()">🧠 貝葉斯優化</button>
                        <div class="enhancement-desc">自動調整最佳參數</div>
                    </div>
                </div>
            </div>

            <div id="topFivePanel" style="margin-top: 16px; padding: 12px; background: rgba(255,255,255,0.06); border-radius: 8px;">
                <div style="display:flex; justify-content:space-between; align-items:center;">
                    <h3 style="font-size: 16px; color:#64b5f6;">🏆 Top five most similar flights</h3>
                    <span id="topFiveAlgoLabel" style="font-size:12px; opacity:0.8;">(尚未分析)</span>
                </div>
                <ul id="topFiveList" style="list-style:none; margin-top:10px; display:grid; gap:8px; padding:0;"></ul>
                <div id="topFiveEmpty" style="font-size:12px; opacity:0.8;">請先執行分析來顯示結果</div>
            </div>

            <div id="explainPanel" style="margin-top: 12px; padding: 12px; background: rgba(255,255,255,0.06); border-radius: 8px;">
                <h3 style="font-size: 16px; color:#aed581;">🧭 目的地推估 / 分析原因</h3>
                <div id="destSummary" style="font-size: 12px; opacity: 0.9; margin-top:6px;">尚未分析</div>
                <ul id="destDetails" style="list-style: none; padding: 0; margin-top: 8px; display: grid; gap: 6px;"></ul>
            </div>
            
            <div style="margin-top: 20px; padding: 10px; background: rgba(255,255,255,0.05); border-radius: 5px; font-size: 12px;">
                <p><strong>使用說明：</strong></p>
                <p>1. 載入航班數據</p>
                <p>2. 調整顯示數量</p>
                <p>3. 在地圖上繪製軌跡</p>
                <p>4. 使用多演算法預測</p>
            </div>
        </div>
        
        <div class="map-container">
            <div id="map"></div>
            <div class="status" id="status">🟢 系統就緒</div>
            <div id="progressContainer" class="progress-container" style="display:none;">
                <div id="progressPrimary" class="progress-item primary">
                    <div class="pi-header"><span class="pi-label">處理中…</span><span class="pi-meta">0% · ETA --</span></div>
                    <div class="pi-bar"><div class="pi-fill" style="width:0%"></div></div>
                </div>
                <div id="progressSecondary" class="progress-secondary-wrap"></div>
            </div>
        </div>
    </div>

    <!-- 小型演算法選擇視窗 -->
    <div id="algorithmModal" class="algorithm-modal">
        <div class="algorithm-header">
            <h3>🎯 演算法選擇</h3>
            <button class="close-btn" onclick="closeAlgorithmModal()">&times;</button>
        </div>
        
        <div class="algorithm-list">
            <div class="algorithm-item" onclick="selectAlgorithm('dtw')" id="alg-dtw">
                <div class="algorithm-name">DTW 動態時間規整</div>
                <div class="algorithm-accuracy">等待計算...</div>
            </div>

            <div class="algorithm-item" onclick="selectAlgorithm('subseq_dtw')" id="alg-subseq_dtw">
                <div class="algorithm-name">Subsequence DTW 子序列DTW</div>
                <div class="algorithm-accuracy">適合部分軌跡</div>
            </div>
            
            <div class="algorithm-item" onclick="selectAlgorithm('lcss')" id="alg-lcss">
                <div class="algorithm-name">LCSS 最長公共子序列</div>
                <div class="algorithm-accuracy">等待計算...</div>
            </div>
            
            <div class="algorithm-item" onclick="selectAlgorithm('euclidean')" id="alg-euclidean">
                <div class="algorithm-name">Euclidean Distance</div>
                <div class="algorithm-accuracy">等待計算...</div>
            </div>
            
            <div class="algorithm-item" onclick="selectAlgorithm('frechet')" id="alg-frechet">
                <div class="algorithm-name">Fréchet Distance</div>
                <div class="algorithm-accuracy">等待計算...</div>
            </div>
            
            <div class="algorithm-item" onclick="selectAlgorithm('hausdorff')" id="alg-hausdorff">
                <div class="algorithm-name">Hausdorff Distance</div>
                <div class="algorithm-accuracy">等待計算...</div>
            </div>
            
            <div class="algorithm-item" onclick="selectAlgorithm('edr')" id="alg-edr">
                <div class="algorithm-name">EDR 編輯距離</div>
                <div class="algorithm-accuracy">等待計算...</div>
            </div>
            
            <div class="algorithm-item" onclick="selectAlgorithm('erp')" id="alg-erp">
                <div class="algorithm-name">ERP 編輯實數序列</div>
                <div class="algorithm-accuracy">等待計算...</div>
            </div>

            <!-- 集成算法已移除 -->
        </div>
        
        <div class="algorithm-controls">
            <button class="compare-btn" style="background:#03a9f4" onclick="runAllAlgorithms()">⚡ 一次跑七種演算法</button>
            <button class="predict-btn" onclick="runPrediction()">🚀 開始預測</button>
            <button class="compare-btn" style="background:#2196f3" onclick="showTopFiveNow()">🏆 顯示 Top 5 航班</button>
            <button class="compare-btn" style="background:#00897b" onclick="toggleBBoxFilter()">🧱 矩形範圍篩選</button>
            <button class="clear-btn" onclick="clearPredictions()">🗑️ 清除</button>
            <button class="compare-btn" onclick="comparePredictions()">📊 比較</button>
        </div>
    </div>

    <script>
        let map;
        let drawingManager;
        let flightData = [];
        let allFlightData = [];
        let flightPaths = [];
        let drawnPath = [];
    let drawnPolyline = null; // 目前畫在地圖上的使用者繪製折線
        let currentFlightCount = 50;
        let currentAlgorithm = 'dtw';
        let predictionResults = {};
    let progressInterval = null;
    let multiAlgorithmResults = null;
    let bboxFilterEnabled = false;
    let bboxOverlay = null;
    let bboxStrictEnabled = false; // 預設不強制端點都在矩形內
    let minSpanRatio = 0.35; // 預設匹配跨度需達到查詢路徑的 35%
    // Top5 視覺化持久化：保留每個航班的 polyline 與起點標記，便於高亮且不清除其他
    let topFivePolylineMap = {};   // flightId -> google.maps.Polyline
    let topFiveStartMarkers = {};  // flightId -> google.maps.Marker
    let currentTopFiveIds = [];    // 目前顯示在地圖上的 Top5 航班 ID 陣列
    let highlightedFlightId = null; // 當前加粗高亮的航班 ID
    let destinationMarker = null;   // 目的地（與預測終點對齊）標記
    let localEtaTimer = null;       // 本地 ETA 計時器
    let predictedLastPoint = null;  // 最近一次預測路徑的終點
    let predictedNearestAirport = null; // 最近一次預測終點對齊的機場（若有）
    let predictedAirportScores = null;  // 最近一次機場機率列表 [{ap, prob}]
    let weightedDestCenter = null;  // TopN 加權目的地中心（僅作為說明，不上地圖）
    // 機場索引（可從外部 JSON 載入；若無則使用內建示例）
    let airportsIndex = null;
    const builtinAirports = [
        { iata: 'NRT', icao: 'RJAA', name: 'Tokyo Narita', lat: 35.772, lng: 140.392 },
        { iata: 'HND', icao: 'RJTT', name: 'Tokyo Haneda', lat: 35.553, lng: 139.781 },
        { iata: 'TPE', icao: 'RCTP', name: 'Taipei Taoyuan', lat: 25.079, lng: 121.232 },
        { iata: 'KIX', icao: 'RJBB', name: 'Osaka Kansai',  lat: 34.435, lng: 135.243 },
        { iata: 'HKG', icao: 'VHHH', name: 'Hong Kong',      lat: 22.308, lng: 113.918 },
        { iata: 'ICN', icao: 'RKSI', name: 'Seoul Incheon',  lat: 37.469, lng: 126.450 },
        { iata: 'NGO', icao: 'RJGG', name: 'Chubu Centrair', lat: 34.858, lng: 136.805 },
        { iata: 'FUK', icao: 'RJFF', name: 'Fukuoka',        lat: 33.586, lng: 130.451 },
        { iata: 'CTS', icao: 'RJCC', name: 'New Chitose',    lat: 42.775, lng: 141.692 }
    ];
    // 多任務進度管理
    const progressTasks = new Map(); // id -> { id, label, percent, eta, indeterminate, priority, etaTimer }

    // 後端任務標籤
    const SERVER_TASK_LABELS = {
        'identify': '相似分析',
        'identify-all': '多演算法分析',
        'forecast-consensus': '共識預測',
        'predict-lstm': 'LSTM 預測',
        'optimize': '參數優化'
    };

    function ensureProgressVisible() {
        const c = document.getElementById('progressContainer');
        if (c) c.style.display = progressTasks.size ? 'block' : 'none';
    }

    function renderProgress() {
        const primary = document.getElementById('progressPrimary');
        const secondaryWrap = document.getElementById('progressSecondary');
        if (!primary || !secondaryWrap) return;
        // 排序：priority 大在前，同 priority 用加入順序（Map 迭代順序）
        const items = Array.from(progressTasks.values()).sort((a, b) => (b.priority||0) - (a.priority||0));
        const main = items[0];
        const rest = items.slice(1);
        // 主任務
        const pLabel = primary.querySelector('.pi-label');
        const pMeta = primary.querySelector('.pi-meta');
        const pFill = primary.querySelector('.pi-fill');
        if (main) {
            pLabel.textContent = main.label || '處理中…';
            pMeta.textContent = `${Math.round(main.percent||0)}% · ETA ${formatETA(main.eta)}`;
            pFill.style.width = `${Math.max(0, Math.min(100, Math.round(main.percent||0)))}%`;
            if (main.indeterminate) pFill.classList.add('indeterminate'); else pFill.classList.remove('indeterminate');
            primary.style.display = '';
        } else {
            primary.style.display = 'none';
        }
        // 其餘任務（小條）
        secondaryWrap.innerHTML = '';
        rest.forEach(task => {
            const div = document.createElement('div');
            div.className = 'progress-item secondary';
            div.innerHTML = `<div class="pi-header"><span class="pi-label">${task.label||'處理中…'}</span><span class="pi-meta">${Math.round(task.percent||0)}% · ETA ${formatETA(task.eta)}</span></div>
                             <div class="pi-bar"><div class="pi-fill${task.indeterminate?' indeterminate':''}" style="width:${Math.max(0, Math.min(100, Math.round(task.percent||0)))}%"></div></div>`;
            secondaryWrap.appendChild(div);
        });
        ensureProgressVisible();
    }

    function addProgressTask(id, label, options={}) {
        const task = {
            id,
            label: label || '處理中…',
            percent: 0,
            eta: null,
            indeterminate: !!options.indeterminate,
            priority: options.priority || 0,
            etaTimer: null
        };
        progressTasks.set(id, task);
        renderProgress();
        return task;
    }

    function updateProgressTask(id, updates={}) {
        const t = progressTasks.get(id);
        if (!t) return;
        Object.assign(t, updates);
        renderProgress();
    }

    function removeProgressTask(id) {
        const t = progressTasks.get(id);
        if (t && t.etaTimer) { clearInterval(t.etaTimer); }
        progressTasks.delete(id);
        renderProgress();
    }

        function updateStatus(message) {
            const s = document.getElementById('status');
            if (s) s.textContent = message;
            console.log(message);
        }

        function initMap() {
            try {
                console.log('🗺️ 初始化 Google Maps...');
                
                map = new google.maps.Map(document.getElementById('map'), {
                    zoom: 8,
                    center: { lat: 24.0, lng: 121.0 },
                    mapTypeId: google.maps.MapTypeId.ROADMAP
                });

                // 繪圖管理器（隱藏預設控制列，我們自建三鍵控制）
                drawingManager = new google.maps.drawing.DrawingManager({
                    drawingMode: null,
                    drawingControl: false,
                    polylineOptions: {
                        strokeColor: '#ff0000',
                        strokeOpacity: 1.0,
                        strokeWeight: 3
                    }
                });
                
                drawingManager.setMap(map);

                // 繪製完成事件
                google.maps.event.addListener(drawingManager, 'polylinecomplete', function(polyline) {
                    // 移除之前的繪製線
                    if (drawnPolyline) { drawnPolyline.setMap(null); }
                    drawnPolyline = polyline;
                    drawnPath = [];
                    const path = polyline.getPath();
                    
                    for (let i = 0; i < path.getLength(); i++) {
                        const point = path.getAt(i);
                        drawnPath.push({
                            lat: point.lat(),
                            lng: point.lng()
                        });
                    }
                    
                    updateStatus('✅ 軌跡繪製完成，共 ' + drawnPath.length + ' 個點');
                    // 不在繪製後自動預測；需先分析後再觸發預測
                });

                // 添加測試標記
                const testMarker = new google.maps.Marker({
                    position: { lat: 25.0330, lng: 121.5654 },
                    map: map,
                    title: '台北101 - 系統測試',
                    icon: {
                        path: google.maps.SymbolPath.CIRCLE,
                        scale: 8,
                        fillColor: '#4caf50',
                        fillOpacity: 0.8,
                        strokeWeight: 2,
                        strokeColor: '#ffffff'
                    }
                });

                updateStatus('✅ 地圖載入成功！');
                // 載入機場索引（若外部不可用則回退內建）
                preloadAirports();
                // 初始化 LSTM 控制元件
                initLstmControls();
                // 自訂：頂部三鍵（移動、繪製、清除）
                const controlDiv = document.createElement('div');
                controlDiv.style.display = 'flex';
                controlDiv.style.gap = '6px';
                controlDiv.style.background = 'rgba(0,0,0,0.6)';
                controlDiv.style.padding = '6px';
                controlDiv.style.borderRadius = '8px';
                controlDiv.style.backdropFilter = 'blur(6px)';
                const mkBtn = (label, onClick) => {
                    const b = document.createElement('button');
                    b.textContent = label;
                    b.style.border = 'none';
                    b.style.padding = '6px 10px';
                    b.style.borderRadius = '6px';
                    b.style.cursor = 'pointer';
                    b.style.background = '#42a5f5';
                    b.style.color = '#fff';
                    b.style.fontSize = '12px';
                    b.onmouseenter = () => b.style.background = '#1e88e5';
                    b.onmouseleave = () => b.style.background = '#42a5f5';
                    b.onclick = onClick; return b;
                };
                // 移動：關閉繪製模式
                const moveBtn = mkBtn('🖐️ 移動', () => {
                    drawingManager.setDrawingMode(null);
                });
                // 繪製：啟用 polyline 模式
                const drawBtn = mkBtn('✏️ 繪製', () => {
                    drawingManager.setDrawingMode(google.maps.drawing.OverlayType.POLYLINE);
                });
                // 清除：移除目前繪製線與 bbox
                const clearBtn = mkBtn('🧹 清除', () => { clearDrawnPath(); });
                controlDiv.appendChild(moveBtn);
                controlDiv.appendChild(drawBtn);
                controlDiv.appendChild(clearBtn);
                map.controls[google.maps.ControlPosition.TOP_CENTER].push(controlDiv);
                
                // 自動載入數據
                setTimeout(() => {
                    testBackend();
                }, 1000);
                
            } catch (error) {
                updateStatus('❌ 地圖初始化失敗: ' + error.message);
                console.error('地圖錯誤:', error);
            }
        }

        function testBackend() {
            updateStatus('🔍 測試後端連線...');
            startLocalETA(3, '檢查後端');
            
            fetch('/api/statistics')
                .then(response => {
                    if (!response.ok) {
                        throw new Error(`HTTP ${response.status}`);
                    }
                    return response.json();
                })
                .then(data => {
                    updateStatus(`✅ 後端正常！共載入 ${data.total_records} 條記錄，${data.unique_flights} 個航班`);
                })
                .catch(error => {
                    updateStatus(`❌ 後端連線失敗: ${error.message}`);
                    console.error('後端錯誤:', error);
                });
        }

        function loadFlightData() {
            updateStatus('📂 載入航班數據...');
            addProgressTask('load:data', '下載航班', { indeterminate: true, priority: 90 });
            // 使用帶路徑的API獲取完整數據
            fetch('/api/flights-with-paths?limit=' + currentFlightCount)
                .then(response => {
                    if (!response.ok) {
                        throw new Error(`HTTP ${response.status}`);
                    }
                    return response.json();
                })
                .then(data => {
                    // 轉換數據格式以匹配 showAllFlights 的期望
                    allFlightData = data.map(flight => ({
                        id: flight.id,
                        coordinates: flight.path, // path 已經是 [{lat, lng}, ...] 格式
                        segment: flight.segment,
                        source: flight.source,
                        points: flight.points
                    }));
                    
                    flightData = allFlightData.slice(0, currentFlightCount);
                    
                    updateStatus(`✅ 已載入 ${flightData.length} 個航班數據 (含路徑)`);
                    console.log('航班數據載入完成:', flightData.length);
                })
                .catch(error => {
                    updateStatus(`❌ 數據載入失敗: ${error.message}`);
                    console.error('載入錯誤:', error);
                })
                .finally(() => { removeProgressTask('load:data'); hideProgress(); });
        }

        function showAllFlights() {
            if (flightData.length === 0) {
                updateStatus('❌ 請先載入數據');
                return;
            }
            
            updateStatus(`🔄 顯示 ${flightData.length} 條航線...`);
            startLocalETA(4, '繪製航線');
            hideAllFlights();
            
            let displayCount = 0;
            const maxDisplay = flightData.length; // 顯示所有載入的數據
            
            flightData.slice(0, maxDisplay).forEach((flight, index) => {
                if (flight.coordinates && flight.coordinates.length >= 2) {
                    // 正規化並去重，確保連續顯示
                    const path = normalizePathCoords(flight.coordinates);
                    
                    const colors = ['#ff4444', '#44ff44', '#4444ff', '#ffff44', '#ff44ff', '#44ffff'];
                    
                    const polyline = new google.maps.Polyline({
                        path: path,
                        geodesic: true,
                        strokeColor: colors[index % colors.length],
                        strokeOpacity: 0.8,
                        strokeWeight: 2
                    });
                    
                    polyline.setMap(map);
                    flightPaths.push(polyline);
                    displayCount++;
                }
            });
            
            updateStatus(`✅ 已顯示 ${displayCount} 條航線`);
        }

        function hideAllFlights() {
            startLocalETA(1, '清除航線');
            flightPaths.forEach(path => {
                path.setMap(null);
            });
            flightPaths = [];
            updateStatus('🚫 已隱藏所有航線');
        }

        function setFlightCount(count) {
            currentFlightCount = count;
            const slider = document.getElementById('flightCountSlider');
            if (slider) slider.value = count;
            updateSliderDisplay();
            updateStatus(`🔧 設定顯示 ${formatNumber(count)} 個航班`);
        }

        function updateSliderDisplay() {
            const slider = document.getElementById('flightCountSlider');
            const count = slider ? slider.value : currentFlightCount;
            const disp = document.getElementById('flightCountDisplay');
            if (disp) disp.textContent = formatNumber(count);
            currentFlightCount = parseInt(count);
        }

        function formatNumber(num) {
            if (num >= 1000000) {
                return (num / 1000000).toFixed(1) + 'M';
            } else if (num >= 1000) {
                return (num / 1000).toFixed(0) + 'K';
            }
            return num.toString();
        }

        // 演算法視窗功能
        function openAlgorithmModal() {
            const m = document.getElementById('algorithmModal');
            if (m) m.style.display = 'block';
            updateStatus('🎯 開啟演算法選擇視窗');
        }

        function closeAlgorithmModal() {
            const m = document.getElementById('algorithmModal');
            if (m) m.style.display = 'none';
            updateStatus('🔧 關閉演算法視窗');
        }

        function selectAlgorithm(algorithm) {
            // 清除所有選中狀態
            document.querySelectorAll('.algorithm-item').forEach(item => {
                item.classList.remove('selected');
            });
            
            // 選中當前演算法
            const algEl = document.getElementById('alg-' + algorithm);
            if (algEl) algEl.classList.add('selected');
            currentAlgorithm = algorithm;
            
            updateStatus(`✅ 選擇演算法: ${getAlgorithmName(algorithm)}`);

            // 若已經有一次「全部演算法」的結果，切換演算法時直接顯示該演算法的 Top 5
            if (multiAlgorithmResults && multiAlgorithmResults[algorithm]) {
                displaySimilarFlights(multiAlgorithmResults[algorithm]);
                updateTopFiveList(multiAlgorithmResults[algorithm], algorithm);
            }
        }

        // 若可用，第一次分析時自動在背景啟動貝葉斯優化（避免手動按鈕）
        async function maybeKickOffOptimizer() {
            try {
                if (window.__optKickStarted) return;
                const stat = await fetch('/api/statistics').then(r => r.ok ? r.json() : null).catch(()=>null);
                const ok = stat && stat.enhancements && stat.enhancements.bayesian_optimizer;
                if (!ok) return;
                const last = Number(localStorage.getItem('lastOptTs') || 0);
                const threeDays = 3 * 24 * 60 * 60 * 1000;
                if ((Date.now() - last) < threeDays) return;
                window.__optKickStarted = true;
                // 小規模嘗試即可，不阻塞操作
                fetch('/api/optimize-parameters', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ n_calls: 25, eval_total: 120 })
                }).then(() => {
                    localStorage.setItem('lastOptTs', String(Date.now()));
                }).catch(()=>{});
            } catch(_) {}
        }

    function runPrediction() {
            if (drawnPath.length < 2) {
                alert('⚠️ 請先在地圖上繪製一條軌跡路徑！');
                return;
            }
            // 自動啟動一次背景參數優化（若近期未執行）
            maybeKickOffOptimizer();
            
            const algorithmName = getAlgorithmName(currentAlgorithm);
            const useEnhanced = true; // 永遠啟用增強算法
            
            updateStatus(`🎯 使用 ${algorithmName} (增強版) 分析軌跡...`);
            
            // 準備發送到後端的路徑數據（Fast Mode 會降採樣）
            const raw = drawnPath.map(point => ({ lat: point.lat, lng: point.lng }));
            const pathData = document.getElementById('fastMode').checked ? downsamplePath(raw, 2) : raw;
            
            // 不再提供手動開關，先進行相似度分析，完成後自動觸發 LSTM
            
            // 構建API URL（包含增強模式參數）
            let apiUrl = `/api/identify?algo=${currentAlgorithm.toUpperCase()}&calibrate_percent=true&percent_mode=absolute&floor_pct=1&top_pct=100&time_budget_s=35`;
            apiUrl += '&enhanced=true';
            if (document.getElementById('fastMode').checked) {
                // 與後端對齊，使用 subseq=true 參數名
                apiUrl += '&subseq=true&stride=3&approx=true&fast=true&directional=true';
            }
            // 若啟用矩形過濾則附加 bbox 參數
            if (bboxFilterEnabled) {
                const bb = computeDrawnPathBBox();
                if (bb) {
                    const { minLat, minLng, maxLat, maxLng } = bb;
                    // 與後端 API 對齊參數名稱: north/south/east/west
                    apiUrl += `&north=${maxLat}&south=${minLat}&east=${maxLng}&west=${minLng}`
                        + `&bbox_strict=${bboxStrictEnabled}`
                        + `&min_span_ratio=${minSpanRatio}`;
                }
            }
            
            // 調用後端API進行真實分析
            addProgressTask('server:progress', '伺服器分析', { priority: 100 });
            startProgressPolling();
            startLocalETA(10, '分析軌跡');
            fetch(apiUrl, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify(pathData)
            })
            .then(response => {
                if (!response.ok) {
                    throw new Error(`後端API錯誤: ${response.status}`);
                }
                return response.json();
            })
            .then(results => {
                if (results && results.length > 0) {
                    updateStatus(`✅ ${algorithmName} (增強版) 找到 ${results.length} 個相似航班`);
                    
                    // 顯示置信度信息（如果有）
                    if (results[0].confidence !== undefined) {
                        const avgConfidence = results.reduce((sum, r) => sum + (r.confidence || 0), 0) / results.length;
                        console.log(`📊 平均置信度: ${(avgConfidence * 100).toFixed(1)}%`);
                    }
                    
                    // 顯示相似航班結果
                    displaySimilarFlights(results);
                    updateTopFiveList(results, currentAlgorithm);
                    // 目的地推估 / 分析原因
                    updateDestinationEstimates(results);
                    
                    // 儲存真實結果
                    predictionResults[currentAlgorithm] = {
                        results: results,
                        algorithm: currentAlgorithm,
                        timestamp: Date.now()
                    };

                    // 清除之前的「全部演算法」快取以避免混淆
                    multiAlgorithmResults = null;
                    
                    // 更新演算法準確率顯示
                    const accuracy = calculateRealAccuracy(results);
                    const accEl = document.querySelector(`#alg-${currentAlgorithm} .algorithm-accuracy`);
                    if (accEl) accEl.textContent = `找到 ${results.length} 個相似航班`;
                    // 分析完成後僅執行共識預測（包含終點保護）；把 Top IDs 傳給共識預測避免二次掃全庫
                    try { autoPredictAfterAnalysis(results); } catch(_) {}
                        
                } else {
                    updateStatus(`❌ ${algorithmName} 沒有找到相似航班`);
                }
            })
            .catch(error => {
                updateStatus(`❌ ${algorithmName} 分析失敗: ${error.message}`);
                console.error('預測錯誤:', error);
            })
            .finally(() => {
                // 交給多任務輪詢自動管理；本地只移除臨時任務
                hideProgress();
            });
        }

        // 一次運行所有演算法，並顯示每個演算法的 Top 5
        async function runAllAlgorithms() {
            if (drawnPath.length < 2) {
                alert('⚠️ 請先在地圖上繪製一條軌跡路徑！');
                return;
            }
            const useEnhanced = true; // 永遠啟用增強算法
            const raw = drawnPath.map(p => ({ lat: p.lat, lng: p.lng }));
            const pathData = document.getElementById('fastMode').checked ? downsamplePath(raw, 2) : raw;
            updateStatus('⚡ 一次運行所有演算法中…');
            addProgressTask('server:progress', '七種演算法分析', { priority: 100 });
            startProgressPolling();
            startLocalETA(15, '七種演算法分析');
            try {
                let url = '/api/identify-all?enhanced=true&calibrate_percent=true&percent_mode=absolute&floor_pct=1&top_pct=100';
                if (document.getElementById('fastMode').checked) {
                    // 與後端對齊，使用 subseq=true 參數名
                    url += (url.includes('?') ? '&' : '?') + 'subseq=true&stride=3&approx=true&fast=true&directional=true';
                }
                if (bboxFilterEnabled) {
                    const bb = computeDrawnPathBBox();
                    if (bb) {
                        const { minLat, minLng, maxLat, maxLng } = bb;
                        // 與後端 API 對齊參數名稱: north/south/east/west
                        url += (url.includes('?') ? '&' : '?')
                            + `north=${maxLat}&south=${minLat}&east=${maxLng}&west=${minLng}`
                            + `&bbox_strict=${bboxStrictEnabled}`
                            + `&min_span_ratio=${minSpanRatio}`;
                    }
                }
                const r = await fetch(url, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(pathData)
                });
                if (!r.ok) throw new Error(`HTTP ${r.status}`);
                const data = await r.json();
                // 後端格式: { results: { DTW: [...], ...}, algorithms: [...], total_flights: N }
                const resultMap = (data && data.results) ? data.results : data;
                // 正規化鍵為小寫，避免大小寫不一致
                const normalized = {};
                Object.keys(resultMap || {}).forEach(k => { normalized[(k || '').toLowerCase()] = resultMap[k]; });
                multiAlgorithmResults = normalized; // 形如 { dtw: [...], lcss: [...], ... }
                // 也同步存入 comparison 儲存，以便「比較」按鈕可用
                predictionResults = {};
                const now = Date.now();
                Object.keys(multiAlgorithmResults).forEach(k => {
                    const arr = multiAlgorithmResults[k] || [];
                    predictionResults[k] = { results: arr, algorithm: k, timestamp: now };
                });
                updateAlgorithmAccuracies();
                updateStatus('✅ 所有演算法完成。點選演算法卡片可切換查看 Top 5 結果');
                // 顯示當前選中演算法結果
                if (multiAlgorithmResults[currentAlgorithm] && multiAlgorithmResults[currentAlgorithm].length) {
                    const res = multiAlgorithmResults[currentAlgorithm];
                    displaySimilarFlights(res);
                    updateTopFiveList(res, currentAlgorithm);
                    updateDestinationEstimates(res);
                    // 分析完成後自動預測（包含終點保護）
                    autoPredictAfterAnalysis(res);
                }
            } catch (e) {
                updateStatus(`❌ 全演算法運行失敗: ${e.message}`);
                console.error(e);
            } finally {
                hideProgress();
            }
        }

        // 計算使用者繪線的矩形邊界
        function computeDrawnPathBBox() {
            if (!drawnPath || drawnPath.length === 0) return null;
            let minLat =  90, maxLat = -90, minLng =  180, maxLng = -180;
            drawnPath.forEach(p => {
                if (p.lat < minLat) minLat = p.lat;
                if (p.lat > maxLat) maxLat = p.lat;
                if (p.lng < minLng) minLng = p.lng;
                if (p.lng > maxLng) maxLng = p.lng;
            });
            // 加入少量邊界 padding（5% 或最少 0.05 度）避免把合理候選切掉
            const spanLat = Math.max(1e-6, maxLat - minLat);
            const spanLng = Math.max(1e-6, maxLng - minLng);
            const padLat = Math.max(0.05, spanLat * 0.05);
            const padLng = Math.max(0.05, spanLng * 0.05);
            minLat = Math.max(-90, minLat - padLat);
            maxLat = Math.min(90,  maxLat + padLat);
            minLng = Math.max(-180, minLng - padLng);
            maxLng = Math.min(180,  maxLng + padLng);
            return { minLat: +minLat.toFixed(6), minLng: +minLng.toFixed(6), maxLat: +maxLat.toFixed(6), maxLng: +maxLng.toFixed(6) };
        }

        // 開關矩形過濾，並在地圖上畫出矩形
        function toggleBBoxFilter() {
            bboxFilterEnabled = !bboxFilterEnabled;
            const bb = computeDrawnPathBBox();
            if (!bb) { alert('請先畫一條路徑'); bboxFilterEnabled = false; return; }
            // 清除舊的覆蓋
            if (bboxOverlay) { bboxOverlay.setMap(null); bboxOverlay = null; }
            if (bboxFilterEnabled) {
                const sw = new google.maps.LatLng(bb.minLat, bb.minLng);
                const ne = new google.maps.LatLng(bb.maxLat, bb.maxLng);
                bboxOverlay = new google.maps.Rectangle({
                    strokeColor: '#00897b', strokeOpacity: 0.9, strokeWeight: 2,
                    fillColor: '#00897b', fillOpacity: 0.08,
                    map: map, bounds: new google.maps.LatLngBounds(sw, ne)
                });
                updateStatus(`🧱 已啟用矩形過濾：(${bb.minLat}, ${bb.minLng}) ~ (${bb.maxLat}, ${bb.maxLng})`);
            } else {
                updateStatus('🧱 已關閉矩形過濾');
            }
        }

        function updateAlgorithmAccuracies() {
            if (!multiAlgorithmResults) return;
            const allKeys = Object.keys(multiAlgorithmResults);
            allKeys.forEach(k => {
                const el = document.querySelector('#alg-' + (k || '').toLowerCase() + ' .algorithm-accuracy');
                if (!el) return;
                const arr = multiAlgorithmResults[k] || [];
                if (!arr.length) { el.textContent = '沒有結果'; return; }
                const top = arr.slice(0,5);
                const scores = top.map(x => (Number(x.score)||0));
                const w = weightsFromScores(scores);
                const sf = softmax(w, 0.8);
                const bestPct = Math.max(...sf) * 100;
                el.textContent = `Top5 就緒 | 最佳相似度 ${(bestPct).toFixed(1)}%`;
            });
        }

        // 從 Top-N 結果推估目的地：以 1/(score+eps) 為權重對 Top-5 終點進行加權，並輸出說明
    async function updateDestinationEstimates(results) {
            try {
                const destSummary = document.getElementById('destSummary');
                const destDetails = document.getElementById('destDetails');
                if (!destSummary || !destDetails) return;
                destDetails.innerHTML = '';
                if (!Array.isArray(results) || results.length === 0) {
            weightedDestCenter = null;
            destSummary.textContent = '尚未分析';
                    return;
                }
                const top = results.slice(0, 5);
                // 取得每個候選航班的終點
                const endPoints = [];
                for (let i = 0; i < top.length; i++) {
                    const r = top[i];
                    try {
                        const flight = await fetch(`/api/flight/${encodeURIComponent(r.flight)}`).then(x => x.json());
                        if (flight && Array.isArray(flight.coordinates) && flight.coordinates.length) {
                            const end = flight.coordinates[flight.coordinates.length - 1];
                            const weight = 1.0 / ((Number(r.score) || 0.0001) + 1e-6);
                            endPoints.push({ id: r.flight, end, weight, score: r.score });
                        }
                    } catch (_) {}
                }
                if (!endPoints.length) { weightedDestCenter = null; destSummary.textContent = '無法推估目的地（無有效候選）'; return; }
                // 加權中心
                const wSum = endPoints.reduce((s, e) => s + e.weight, 0);
                const center = endPoints.reduce((acc, e) => ({ lat: acc.lat + e.end.lat * e.weight, lng: acc.lng + e.end.lng * e.weight }), { lat: 0, lng: 0 });
                center.lat /= wSum; center.lng /= wSum;
                weightedDestCenter = center;
                // 簡單一致性：平均終點間距（km）
                let spread = 0, pairs = 0;
                for (let i = 0; i < endPoints.length; i++) {
                    for (let j = i + 1; j < endPoints.length; j++) {
                        spread += haversineKm(endPoints[i].end, endPoints[j].end); pairs++;
                    }
                }
                const avgSpread = pairs ? spread / pairs : 0;
                // 說明與列表（用百分比權重，不顯示原始分數）
                const eps = 1e-6;
                const wArr = endPoints.map(e => 1/((Number(e.score)||0)+eps));
                const wSum2 = wArr.reduce((a,b)=>a+b,0) || 1;
                const lines = endPoints.map((e, idx) => {
                    const pct = (wArr[idx]/wSum2*100).toFixed(1);
                    return `#${idx+1} ${e.id} · 貢獻 ${pct}% · 終點 (${e.end.lat.toFixed(3)}, ${e.end.lng.toFixed(3)})`;
                });
                // 更新摘要（不要在這裡畫地圖標記）
                destSummary.textContent = predictedLastPoint
                    ? `預測終點：(${predictedLastPoint.lat.toFixed(3)}, ${predictedLastPoint.lng.toFixed(3)}) · 候選加權中心：(${center.lat.toFixed(3)}, ${center.lng.toFixed(3)}) · 差距 ≈ ${haversineKm(predictedLastPoint, center).toFixed(1)} km · 一致性 ≈ ${avgSpread.toFixed(1)} km`
                    : `候選加權中心：(${center.lat.toFixed(3)}, ${center.lng.toFixed(3)}) · 一致性(越小越一致) ≈ ${avgSpread.toFixed(1)} km`;
                lines.forEach(t => {
                    const li = document.createElement('li');
                    li.style.fontSize = '12px';
                    li.style.opacity = '0.9';
                    li.textContent = t;
                    destDetails.appendChild(li);
                });
            } catch (e) {
                console.error('更新目的地推估時發生錯誤', e);
            }
        }

        function refreshDestinationSummary() {
            try {
                const destSummary = document.getElementById('destSummary');
                if (!destSummary) return;
                if (!predictedLastPoint && !weightedDestCenter) { destSummary.textContent = '尚未分析'; return; }
                const predLabel = predictedNearestAirport
                    ? (() => {
                        let pct = '';
                        if (predictedAirportScores && predictedAirportScores.length && predictedAirportScores[0].ap === predictedNearestAirport) {
                            pct = ` ${(predictedAirportScores[0].prob*100).toFixed(1)}%`;
                        }
                        return `預測終點：${predictedNearestAirport.iata||predictedNearestAirport.icao||''} ${predictedNearestAirport.name||''}${pct}`;
                    })()
                    : `預測終點：(${predictedLastPoint ? predictedLastPoint.lat.toFixed(3)+', '+predictedLastPoint.lng.toFixed(3) : '--'})`;
                if (predictedLastPoint && weightedDestCenter) {
                    destSummary.textContent = `${predLabel} · 候選加權中心：(${weightedDestCenter.lat.toFixed(3)}, ${weightedDestCenter.lng.toFixed(3)}) · 差距 ≈ ${haversineKm(predictedLastPoint, weightedDestCenter).toFixed(1)} km`;
                } else if (predictedLastPoint) {
                    destSummary.textContent = predLabel;
                } else if (weightedDestCenter) {
                    destSummary.textContent = `候選加權中心：(${weightedDestCenter.lat.toFixed(3)}, ${weightedDestCenter.lng.toFixed(3)})`;
                }
            } catch (_) {}
        }

        // 清除目前繪製的路徑與矩形過濾
        function clearDrawnPath() {
            try {
                if (drawnPolyline) { drawnPolyline.setMap(null); drawnPolyline = null; }
                drawnPath = [];
                // 關閉並移除當前 bbox 覆蓋
                if (bboxOverlay) { bboxOverlay.setMap(null); bboxOverlay = null; }
                bboxFilterEnabled = false;
                updateStatus('🧹 已清除繪製路徑與矩形過濾');
            } catch (e) {
                console.error('清除繪製路徑失敗', e);
            }
        }

        // 進度條相關
    // 兼容舊介面：showProgress 只確保容器可見（多任務由 addProgressTask 控制）
    function showProgress() { ensureProgressVisible(); }

        function hideProgress() {
                // 僅隱藏容器；實際關閉由各任務 removeProgressTask 處理
                // 保持輪詢，以便同時顯示多個任務；當無任務時容器自動隱藏
            if (localEtaTimer) { clearInterval(localEtaTimer); localEtaTimer = null; }
            ensureProgressVisible();
        }

        // 本地 ETA（生成一個次要任務，不佔用主要條；可指定 priority 決定是否置頂）
        function startLocalETA(seconds = 5, label = '處理中', priority = 0) {
            try {
                const id = `local:${label}:${Date.now()}`;
                const task = addProgressTask(id, label, { indeterminate: true, priority });
                let remain = Math.max(1, Math.round(seconds));
                task.eta = remain; task.indeterminate = true; task.percent = 0;
                renderProgress();
                if (task.etaTimer) clearInterval(task.etaTimer);
                task.etaTimer = setInterval(() => {
                    remain = Math.max(0, remain - 1);
                    updateProgressTask(id, { eta: remain });
                    if (remain <= 0) { clearInterval(task.etaTimer); task.etaTimer = null; removeProgressTask(id); }
                }, 1000);
                return id;
            } catch (_) { return null; }
        }

        // 舊的單一進度更新，改為更新一個標準任務（id: 'server:progress'）
        function updateProgress(percent, etaSeconds) {
            if (!progressTasks.has('server:progress')) addProgressTask('server:progress', '伺服器分析', { priority: 100 });
            updateProgressTask('server:progress', { percent: Math.max(0, Math.min(100, Math.round(percent || 0))), eta: etaSeconds, indeterminate: false });
            // 如果伺服器進度回報，移除本地 ETA 任務避免重疊
            for (const [id] of progressTasks.entries()) {
                if (String(id).startsWith('local:')) removeProgressTask(id);
            }
        }

        function formatETA(secs) {
            if (secs == null || isNaN(secs)) return '--';
            const s = Math.max(0, Math.round(secs));
            const m = Math.floor(s / 60);
            const ss = s % 60;
            return m > 0 ? `${m}m${ss}s` : `${ss}s`;
        }

        function startProgressPolling() {
            showProgress();
            if (progressInterval) { clearInterval(progressInterval); }
            progressInterval = setInterval(async () => {
                try {
                    const r = await fetch('/api/progress');
                    if (!r.ok) return; // 尚未開始或不可用
                    const j = await r.json();
                    const tasks = Array.isArray(j.tasks) ? j.tasks : [];
                    if (tasks.length) {
                        // 以後端多任務為準，同步每個任務一條進度
                        const present = new Set();
                        tasks.forEach(t => {
                            const tname = String(t.task || 'server');
                            const id = `server:${tname}`;
                            present.add(id);
                            const label = t.message || SERVER_TASK_LABELS[tname] || '伺服器任務';
                            if (!progressTasks.has(id)) addProgressTask(id, label, { priority: (tname==='identify'||tname==='identify-all') ? 100 : 90 });
                            updateProgressTask(id, {
                                label,
                                percent: Math.max(0, Math.min(100, Number(t.percent)||0)),
                                eta: (t.eta_seconds != null) ? t.eta_seconds : null,
                                indeterminate: false
                            });
                            // 完成即移除
                            if (t.done) removeProgressTask(id);
                        });
                        // 移除不存在的 server 任務與占位符
                        for (const [id] of progressTasks.entries()) {
                            if (id === 'server:progress') { removeProgressTask(id); continue; }
                            if (id.startsWith('server:') && !present.has(id)) removeProgressTask(id);
                        }
                    } else {
                        // 後端未提供多任務：退回單一占位符
                        const pct = (j && (j.percent != null)) ? j.percent : (j && j.total ? (j.processed / j.total) * 100 : 0);
                        const eta = (j && (j.eta_seconds != null)) ? j.eta_seconds : (j ? j.eta : null);
                        updateProgress(pct, eta);
                    }
                } catch (e) {
                    // 忽略輪詢錯誤
                }
            }, 700);
        }

        // 工具：降採樣路徑以加速
        function downsamplePath(path, factor) {
            if (!Array.isArray(path) || path.length <= 2 || !factor || factor <= 1) return path;
            const out = [];
            for (let i = 0; i < path.length; i += factor) out.push(path[i]);
            if (out[out.length - 1] !== path[path.length - 1]) out.push(path[path.length - 1]);
            return out;
        }

        // 更新左側 Top5 清單
        function updateTopFiveList(results, algorithm) {
            const list = document.getElementById('topFiveList');
            const empty = document.getElementById('topFiveEmpty');
            const label = document.getElementById('topFiveAlgoLabel');
            if (!list || !empty || !label) return;
            list.innerHTML = '';
            if (!results || !results.length) {
                empty.style.display = 'block';
                label.textContent = '(沒有結果)';
                return;
            }
            empty.style.display = 'none';
            label.textContent = `(${getAlgorithmName(algorithm || currentAlgorithm)})`;
            // 計算 Top-5 相對相似度（百分比），避免顯示難看的原始分數；改用 softmax 讓差距更直覺
            const topArr = results.slice(0, 5);
            const eps = 1e-6;
            const scores = topArr.map(x => (Number(x.score)||0));
            const weights = weightsFromScores(scores);
            const ws = weights.length ? weights : topArr.map(()=>1);
            const percents = softmax(ws, 0.8);
            topArr.forEach(async (r, idx) => {
                const li = document.createElement('li');
                li.style.padding = '8px';
                li.style.background = 'rgba(255,255,255,0.05)';
                li.style.borderRadius = '6px';
                li.style.cursor = 'pointer';
                li.title = `點擊以聚焦航班 ${r.flight}`;
                // 先顯示基本行，稍後補上副標題（航班名稱/來源）
                // 優先使用後端提供的 similarity_percent；否則退回 softmax
                const pctVal = (typeof r.similarity_percent === 'number' && isFinite(r.similarity_percent))
                    ? Math.max(0, Math.min(100, r.similarity_percent))
                    : Math.max(0, Math.min(100, (percents[idx] || 0) * 100));
                const pct = pctVal.toFixed(1);
                li.innerHTML = `<div style="display:flex; justify-content:space-between; align-items:center;">
                                        <div>
                                            <div><strong>#${idx + 1}</strong> 航班 <span class="fn">（載入中）</span></div>
                                            <div class="sub" style="font-size:11px; opacity:.85; margin-top:2px;">讀取中…</div>
                                        </div>
                                        <span style="opacity:.9; font-weight:600;">相似度 ${pct}%</span>
                                </div>`;
                li.onclick = () => focusFlight(r.flight, idx);
                list.appendChild(li);
                try {
                    const flight = await fetch(`/api/flight/${encodeURIComponent(r.flight)}`).then(x => x.json());
                    const sub = li.querySelector('.sub');
                                        const fn = li.querySelector('.fn');
                    if (sub) {
                        if (flight && (flight.name || flight.segment || flight.source)) {
                            const name = flight.name || '';
                            const seg = flight.segment ? `段落 ${flight.segment}` : '';
                            const src = flight.source ? `${flight.source}` : '';
                            const pieces = [name, seg, src].filter(Boolean);
                            sub.textContent = pieces.length ? pieces.join(' · ') : '（無其他資訊）';
                        } else {
                            sub.textContent = '（無其他資訊）';
                        }
                    }
                                        if (fn) fn.textContent = formatFlightName(r.flight, flight);
                } catch (_) {
                    const sub = li.querySelector('.sub');
                    if (sub) sub.textContent = '（載入名稱失敗）';
                }
            });
        }

        // 聚焦航班：僅調整線條粗細以高亮，不清除其他 Top5
        async function focusFlight(flightId, rankIndex) {
            try {
                // 還原先前高亮
                if (highlightedFlightId && topFivePolylineMap[highlightedFlightId]) {
                    topFivePolylineMap[highlightedFlightId].setOptions({ strokeWeight: 3, strokeOpacity: 0.85, zIndex: 0 });
                }
                // 確保目標 polyline 存在，若尚未繪製則補繪
                let poly = topFivePolylineMap[flightId];
                if (!poly) {
                    const API_BASE = (window.location.origin && window.location.origin.startsWith('file:')) ? 'http://127.0.0.1:5000' : '';
                    const resp = await fetch(`${API_BASE}/api/flight/${encodeURIComponent(flightId)}`);
                    if (!resp.ok) throw new Error(`HTTP ${resp.status}`);
                    const flight = await resp.json();
                    if (!flight || !flight.coordinates || flight.coordinates.length < 2) return;
                    const norm = normalizePathCoords(flight.coordinates);
                    const color = ['#ff4444', '#44ff44', '#4444ff', '#ffff44', '#ff44ff'][rankIndex % 5] || '#ff8844';
                    poly = new google.maps.Polyline({
                        path: norm,
                        geodesic: true,
                        strokeColor: color,
                        strokeOpacity: 0.85,
                        strokeWeight: 3
                    });
                    poly.setMap(map);
                    topFivePolylineMap[flightId] = poly;
                    currentTopFiveIds.push(flightId);
                }
                // 高亮顯示
                poly.setOptions({ strokeWeight: 6, strokeOpacity: 1.0, zIndex: 1000 });
                highlightedFlightId = flightId;
                // 視野置中於該航班
                const bounds = new google.maps.LatLngBounds();
                const gp = poly.getPath();
                for (let i = 0; i < gp.getLength(); i++) bounds.extend(gp.getAt(i));
                map.fitBounds(bounds);
            } catch (e) {
                console.error('聚焦航班失敗', e);
            }
        }

        // 配置：是否自動觸發 LSTM 預測、是否顯示「發送預測請求中」訊息
    const AUTO_PREDICT_ENABLED = true;    // 分析後自動預測開啟
    const SHOW_PREDICT_STATUS = false;    // 想顯示進度提示時改為 true
    const API_BASE = (window.location.origin && window.location.origin.startsWith('file:')) ? 'http://127.0.0.1:5000' : '';

        // LSTM 深度學習預測（支援 { auto: boolean, horizon?: number } 選項）
        function runLSTMPrediction(pathData, options = {}) {
            if (SHOW_PREDICT_STATUS) updateStatus('🧠 發送預測請求中…');
            addProgressTask('predict:lstm', 'LSTM 預測', { indeterminate: true, priority: 95 });
            startLocalETA(10, 'LSTM 預測');
            // 使用 auto horizon 與後端的動態估計，並指定 model=lstm
            const q = new URLSearchParams({ model: 'lstm' });
            const auto = !!options.auto;
            if (auto) {
                q.set('horizon', 'auto');
                if (typeof options.min === 'number') q.set('min_steps', String(options.min));
                if (typeof options.max === 'number') q.set('max_steps', String(options.max));
                if (typeof options.base === 'number') q.set('base_steps', String(options.base));
            } else if (typeof options.horizon === 'number' && isFinite(options.horizon)) {
                q.set('horizon', String(Math.max(1, Math.round(options.horizon))));
            } else {
                q.set('horizon', 'auto');
            }
            fetch(API_BASE + '/api/predict-trajectory?' + q.toString(), {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(pathData)
            })
            .then(r => {
                if (!r.ok) throw new Error(`LSTM API 錯誤: ${r.status}`);
                return r.json();
            })
            .then(res => {
                if (res.predicted_trajectory && res.predicted_trajectory.length) {
                    const algo = res.algorithm || 'Prediction';
                    if (SHOW_PREDICT_STATUS) updateStatus(`✅ ${algo} 完成，預測 ${res.prediction_horizon} 個未來點`);
                    displayPredictedTrajectory(res.predicted_trajectory);
                } else {
                    if (SHOW_PREDICT_STATUS) updateStatus('❌ LSTM 預測未返回結果');
                }
            })
            .catch(err => {
                if (SHOW_PREDICT_STATUS) updateStatus(`❌ LSTM 預測失敗: ${err.message}`);
                console.error(err);
            })
            .finally(() => { removeProgressTask('predict:lstm'); hideProgress(); });
        }

        // 初始化 LSTM 控制 UI 的事件
        function initLstmControls() {
            try {
                const slider = document.getElementById('lstmHorizon');
                const disp = document.getElementById('lstmHorizonDisplay');
                const autoCk = document.getElementById('lstmAutoHorizon');
                const enableCk = document.getElementById('enableLSTM');
                if (slider && disp) {
                    const sync = () => { disp.textContent = String(slider.value); };
                    slider.addEventListener('input', sync);
                    slider.addEventListener('change', sync);
                    sync();
                }
                if (autoCk && slider) {
                    const toggle = () => { slider.disabled = !!autoCk.checked; slider.style.opacity = autoCk.checked ? 0.6 : 1; };
                    autoCk.addEventListener('change', toggle);
                    toggle();
                }
                if (enableCk) {
                    // 預設不啟用，避免誤觸
                    enableCk.checked = false;
                }
            } catch (_) {}
        }

        // 由按鈕觸發的 LSTM 執行
        function runLSTMNow() {
            try {
                if (!drawnPath || drawnPath.length < 2) { alert('請先在地圖上繪製一條軌跡'); return; }
                const enable = document.getElementById('enableLSTM');
                if (!enable || !enable.checked) { alert('請先打開「LSTM 手動」開關'); return; }
                const auto = !!(document.getElementById('lstmAutoHorizon')?.checked);
                const horizon = Number(document.getElementById('lstmHorizon')?.value || 80);
                const raw = drawnPath.map(p => ({ lat: p.lat, lng: p.lng }));
                const pathData = document.getElementById('fastMode').checked ? downsamplePath(raw, 2) : raw;
                const opts = auto ? { auto: true } : { auto: false, horizon: horizon };
                runLSTMPrediction(pathData, opts);
            } catch (e) {
                console.error('LSTM 觸發失敗', e);
            }
        }

        // 自動預測（分析後觸發）：更穩健的地平線估計，避免過度縮短
    async function autoPredictAfterAnalysis(results) {
            if (!AUTO_PREDICT_ENABLED) return; // 關閉自動預測
            try {
                if (!Array.isArray(results) || results.length === 0 || !drawnPath || drawnPath.length < 2) return;
                const lastPt = drawnPath[drawnPath.length - 1];
                // 1) 速度趨近 0 檢測：最近幾步的平均步距過小則視為抵達
                const recent = drawnPath.slice(Math.max(0, drawnPath.length - 5));
                const avgStepKm = averageStepDistance(recent);
                if (avgStepKm < 0.15) { // < 150m/步
                    updateStatus('🧭 已接近終點（速度極低），跳過未來路徑預測');
                    return;
                }
                // 2) 最近機場距離（km），用於「距離→步數」的連續映射
                let nearestDkm = null;
                // 優先嘗試後端 OpenFlights 最近機場 API，失敗再回退到前端內建名單
                try {
                    const q = new URLSearchParams({ lat: String(lastPt.lat||lastPt.latitude), lng: String(lastPt.lng||lastPt.longitude), k: '1', airport_only: 'true', require_iata: 'true' });
                    const resp = await fetch(API_BASE + '/api/openflights/nearest-airports?' + q.toString());
                    if (resp.ok) {
                        const data = await resp.json();
                        const arr = data && data.nearest ? data.nearest : [];
                        if (arr.length && typeof arr[0].distance_km === 'number' && isFinite(arr[0].distance_km)) {
                            nearestDkm = arr[0].distance_km;
                        }
                    }
                } catch (_) {}
                if (nearestDkm == null) {
                    try {
                        if (airportsIndex && airportsIndex.length) {
                            let best = Number.POSITIVE_INFINITY;
                            for (const ap of airportsIndex) {
                                const d = haversineKm(lastPt, ap);
                                if (d < best) best = d;
                            }
                            if (isFinite(best)) nearestDkm = best;
                        }
                    } catch (_) {}
                }
                // 3) 取得共識預測：使用連續的「距離→步數」映射，不再採用區間內固定步數
                const pathData = drawnPath.map(p => ({ lat: p.lat, lng: p.lng }));
                // UI 顯示距離資訊（連續值）
                const nearMsg = (nearestDkm != null) ? `、距機場≈${nearestDkm.toFixed(0)}km` : '';
                // 估計每步距離：用最近幾步平均，設下限避免步距過小造成步數爆炸
                const stepKm = Math.max(0.3, Math.min(50, isFinite(avgStepKm) ? avgStepKm : 1.0));
                updateStatus(`🧠 共識預測中（距離→步數：${(nearestDkm!=null?nearestDkm.toFixed(0):'--')}km ÷ ${stepKm.toFixed(2)}km/步）…`);
                addProgressTask('predict:consensus', '共識預測', { indeterminate: true, priority: 98 });
                // 也輪詢伺服器進度（若後端提供 ETA / 百分比，會自動同步到主進度條）
                startProgressPolling();
                startLocalETA(7, '共識預測');
                let url = `/api/forecast-consensus?algo=${currentAlgorithm.toUpperCase()}`;
                if (document.getElementById('fastMode').checked) {
                    url += '&subseq=true&stride=3&fast=true&directional=true';
                }
                if (nearestDkm != null && isFinite(nearestDkm)) {
                    url += `&horizon=distance&step_km=${encodeURIComponent(stepKm)}&distance_km=${encodeURIComponent(nearestDkm)}&min_steps=1&max_steps=360`;
                } else {
                    // 後援：若無法估距離，退回 auto（仍可連續變化，無區間固定值）
                    url += `&horizon=auto&min_steps=1&max_steps=360`;
                }
                // 傳入 identify 的 Top IDs，讓後端只在這些候選上做續航與加權
                const topIds = (Array.isArray(results)?results.slice(0,8):[]).map(r => r.flight);
                const res = await fetch(url, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ query_path: pathData, top_flights: topIds }) })
                    .then(r => { if (!r.ok) throw new Error(`HTTP ${r.status}`); return r.json(); });
                let traj = Array.isArray(res.consensus) ? res.consensus.slice() : [];
                if (!traj.length) { updateStatus('⚠️ 共識預測未生成路徑'); return; }
                // 防護上限，避免極端長度
                if (traj.length > 600) traj = traj.slice(0, 600);
                const hmode = res.horizon_mode ? (res.horizon_mode === 'distance' ? '距離' : (res.horizon_mode === 'auto' ? '動態' : '固定')) : '距離';
                updateStatus(`✅ 共識預測完成（${hmode} · Top${res.topN_used||0} · 步數 ${traj.length}）`);
                displayPredictedTrajectory(traj);
            } catch (err) {
                updateStatus(`❌ 自動預測失敗: ${err.message}`);
                console.error(err);
            } finally {
                removeProgressTask('predict:consensus');
                ensureProgressVisible();
            }
        }

        // 顯示友善的航班名稱（盡量萃取 BR357 / ANA123；廣泛掃描字串欄位，避免把日期當成航班號）
        function formatFlightName(flightId, flightObj) {
            const clean = (s) => (typeof s === 'string' ? s.trim() : '');
            const up = (s) => clean(s).toUpperCase();
            const id = up(flightId);
            const f = flightObj || {};

            // 更寬鬆的解析：允許空格/連字號/底線分隔；避免 8 位日期（20xxxxxx）
            const tryExtractFromString = (str) => {
                const s = up(str);
                if (!s) return '';
                // 取所有可能匹配，選擇第一個合理者
                const re = /\b([A-Z]{2,3})[ _-]?(\d{2,5})([A-Z]?)\b/g;
                let m;
                while ((m = re.exec(s)) !== null) {
                    const letters = m[1];
                    let digits = m[2];
                    const suffix = m[3] || '';
                    // 濾掉日期樣式，例如 20250807、202501、200101
                    if ((digits.length >= 6 && /^20\d{4,}$/.test(digits)) || /^\d{6,}$/.test(digits)) continue;
                    digits = String(parseInt(digits, 10)); // 去前導 0
                    if (!digits || digits === 'NaN') continue;
                    return letters + digits + suffix;
                }
                return '';
            };

            // 從常見欄位優先
            const primaryKeys = ['callsign', 'flight_number', 'ident', 'name', 'iata', 'icao', 'number'];
            for (const k of primaryKeys) {
                if (k in f) {
                    const code = tryExtractFromString(f[k]);
                    if (code) return code;
                }
            }
            // 若無，掃描物件所有字串欄位（含淺層物件/陣列）
            const visited = new Set();
            const scan = (obj, depth=0) => {
                if (!obj || typeof obj !== 'object' || depth > 2 || visited.has(obj)) return '';
                visited.add(obj);
                if (Array.isArray(obj)) {
                    for (const v of obj) {
                        if (typeof v === 'string') { const c = tryExtractFromString(v); if (c) return c; }
                        if (typeof v === 'object') { const c = scan(v, depth+1); if (c) return c; }
                    }
                } else {
                    for (const key of Object.keys(obj)) {
                        const v = obj[key];
                        if (typeof v === 'string') { const c = tryExtractFromString(v); if (c) return c; }
                        if (typeof v === 'object') { const c = scan(v, depth+1); if (c) return c; }
                    }
                }
                return '';
            };
            const deepCode = scan(f, 0);
            if (deepCode) return deepCode;

            // 再嘗試從 id 本身擷取
            const idCode = tryExtractFromString(id);
            if (idCode) return idCode;

            // 仍無法：提供中性占位並附上 id 末碼，以便區分
            const suffix = (id.match(/([A-Z0-9]{4,})$/) || [,''])[1];
            return suffix ? `未知航班 (${suffix})` : '未知航班';
        }

        // 工具：平均步距（km）
        function averageStepDistance(points) {
            if (!Array.isArray(points) || points.length < 2) return Infinity;
            let sum = 0, cnt = 0;
            for (let i = 1; i < points.length; i++) {
                sum += haversineKm(points[i-1], points[i]);
                cnt++;
            }
            return cnt ? (sum / cnt) : Infinity;
        }

        // 工具：分位數（p ∈ (0,1]），簡單就地排序法
        function percentile(arr, p) {
            if (!Array.isArray(arr) || !arr.length) return 0;
            const a = arr.slice().sort((x, y) => x - y);
            const pp = Math.max(0, Math.min(1, Number(p) || 0));
            const idx = Math.min(a.length - 1, Math.round((a.length - 1) * pp));
            return a[idx];
        }

        // 工具：Softmax（把相對權重轉成更直覺的百分比），tau<1 會放大最大值
        function softmax(arr, tau = 1.0) {
            if (!Array.isArray(arr) || !arr.length) return [];
            const t = Math.max(1e-6, Number(tau) || 1.0);
            const scaled = arr.map(x => (Number(x) || 0) / t);
            const m = Math.max(...scaled);
            const exps = scaled.map(v => Math.exp(v - m));
            const s = exps.reduce((a,b)=>a+b, 0) || 1;
            return exps.map(e => e / s);
        }

        function normalizeWeights(arr) {
            const a = Array.isArray(arr) ? arr.slice() : [];
            const s = a.reduce((x,y)=>x+(Number(y)||0), 0);
            if (!(s > 0)) return a.map(_=>1/Math.max(1,a.length));
            return a.map(v => (Number(v)||0)/s);
        }

        // 若分布過於平坦，與名次權重混合，避免全部 20%
        function emphasizePercents(percs) {
            if (!Array.isArray(percs) || percs.length === 0) return percs;
            const maxV = Math.max(...percs);
            const sorted = percs.slice().sort((a,b)=>a-b);
            const med = sorted[Math.floor(sorted.length/2)];
            if ((maxV - med) < 0.03) { // <3% 幾乎平坦
                const n = percs.length;
                const rankW = Array.from({length:n}, (_,i)=> (n - i)); // 5,4,3,2,1
                const rankP = normalizeWeights(rankW);
                const blended = percs.map((p,i)=> 0.6*p + 0.4*rankP[i]);
                return normalizeWeights(blended);
            }
            return percs;
        }

        // 工具：依分數產生權重（考量分數落差）。
        // 若分數幾乎相同，回退到按名次的權重（避免全部 20%）。
        function weightsFromScores(scores) {
            const arr = Array.isArray(scores) ? scores.map(x => Number(x)) : [];
            if (!arr.length) return [];
            let minS = Infinity, maxS = -Infinity;
            for (const s of arr) {
                if (!isFinite(s)) continue;
                if (s < minS) minS = s;
                if (s > maxS) maxS = s;
            }
            if (!isFinite(minS) || !isFinite(maxS)) {
                // 資料異常，平均分配
                return arr.map(_ => 1);
            }
            const spread = maxS - minS;
            if (spread < 1e-6) {
                // 幾乎相同分數：用名次區分（5,4,3,2,1...）
                return arr.map((_, i) => Math.max(1, (arr.length - i)));
            }
            const scale = Math.max(spread / 3, 1e-6);
            return arr.map(s => Math.exp(-(s - minS) / scale));
        }

        // 工具：Haversine 距離（km）
        function haversineKm(a, b) {
            const toRad = d => d * Math.PI / 180;
            const R = 6371;
            const aLat = a.lat ?? a.latitude, aLng = a.lng ?? a.longitude;
            const bLat = b.lat ?? b.latitude, bLng = b.lng ?? b.longitude;
            const dLat = toRad(bLat - aLat);
            const dLng = toRad(bLng - aLng);
            const lat1 = toRad(aLat);
            const lat2 = toRad(bLat);
            const h = Math.sin(dLat/2)**2 + Math.cos(lat1)*Math.cos(lat2)*Math.sin(dLng/2)**2;
            return 2 * R * Math.asin(Math.sqrt(h));
        }

        // 工具：方位角、目的地點計算
        function bearingDeg(a, b) {
            const toRad = d => d * Math.PI / 180;
            const toDeg = r => r * 180 / Math.PI;
            const lat1 = toRad(a.lat ?? a.latitude), lon1 = toRad(a.lng ?? a.longitude);
            const lat2 = toRad(b.lat ?? b.latitude), lon2 = toRad(b.lng ?? b.longitude);
            const dLon = lon2 - lon1;
            const y = Math.sin(dLon) * Math.cos(lat2);
            const x = Math.cos(lat1)*Math.cos(lat2) * Math.cos(dLon) - Math.sin(lat1)*Math.sin(lat2);
            let brng = toDeg(Math.atan2(y, x));
            if (!isFinite(brng)) return 0;
            return (brng + 360) % 360;
        }
        function destinationPoint(start, bearing, distanceKm) {
            const toRad = d => d * Math.PI / 180;
            const toDeg = r => r * 180 / Math.PI;
            const R = 6371;
            const δ = distanceKm / R;
            const θ = toRad(bearing);
            const φ1 = toRad(start.lat ?? start.latitude);
            const λ1 = toRad(start.lng ?? start.longitude);
            const sinφ1 = Math.sin(φ1), cosφ1 = Math.cos(φ1);
            const sinδ = Math.sin(δ), cosδ = Math.cos(δ);
            const sinφ2 = sinφ1 * cosδ + cosφ1 * sinδ * Math.cos(θ);
            const φ2 = Math.asin(sinφ2);
            const y = Math.sin(θ) * sinδ * cosφ1;
            const x = cosδ - sinφ1 * sinφ2;
            const λ2 = λ1 + Math.atan2(y, x);
            return { lat: toDeg(φ2), lng: ((toDeg(λ2) + 540) % 360) - 180 };
        }
        function angleDiffDeg(a, b) {
            let d = ((a - b + 540) % 360) - 180;
            return Math.abs(d);
        }

        // 速度外推：使用最近 N 段的平均步距與平均方位角，生成未來步
        function computeVelocityExtrapolationPath(basePath, steps = 80) {
            try {
                const pts = Array.isArray(basePath) ? basePath : [];
                if (pts.length < 3) return [];
                const N = Math.min(6, pts.length - 1);
                let totalKm = 0, bearings = [];
                for (let i = pts.length - N - 1; i < pts.length - 1; i++) {
                    const a = pts[i], b = pts[i+1];
                    totalKm += haversineKm(a, b);
                    bearings.push(bearingDeg(a, b));
                }
                const avgStepKm = Math.max(0.5, totalKm / N); // 每步至少 0.5km，避免過短
                // 均值方向（考慮環形平均）
                const toRad = d => d * Math.PI / 180;
                const toDeg = r => r * 180 / Math.PI;
                let sx = 0, sy = 0;
                bearings.forEach(d => { sx += Math.cos(toRad(d)); sy += Math.sin(toRad(d)); });
                const avgBearing = (toDeg(Math.atan2(sy, sx)) + 360) % 360;
                const out = [];
                let cur = pts[pts.length - 1];
                for (let k = 0; k < steps; k++) {
                    cur = destinationPoint(cur, avgBearing, avgStepKm);
                    out.push(cur);
                }
                return out;
            } catch (_) { return []; }
        }

        // 工具：找出座標陣列中距離目標點最近的索引
        function nearestIndex(coords, target) {
            let bestI = 0, bestD = Number.POSITIVE_INFINITY;
            for (let i = 0; i < coords.length; i++) {
                const d = haversineKm(coords[i], target);
                if (d < bestD) { bestD = d; bestI = i; }
            }
            return bestI;
        }

        // 顯示預測軌跡
    async function displayPredictedTrajectory(predictedPoints) {
            // 將預測路徑首點連到用戶最後繪製的點，使視覺上連續
            let pathToDraw = Array.isArray(predictedPoints) ? normalizePathCoords(predictedPoints) : [];
            if (drawnPath && drawnPath.length > 0 && pathToDraw.length > 0) {
                const last = drawnPath[drawnPath.length - 1];
                const first = pathToDraw[0];
                if (last && (last.lat !== first.lat || last.lng !== first.lng)) {
                    pathToDraw.unshift({ lat: last.lat, lng: last.lng });
                }
            }
            // 基於 Top-5 + 速度外推 + 機場鄰近性 來評分可能目的地（以百分比顯示）
            predictedNearestAirport = null;
            predictedAirportScores = null;
            try {
                if (airportsIndex && airportsIndex.length && drawnPath && drawnPath.length >= 3) {
                    const last = drawnPath[drawnPath.length - 1];
                    const velEx = computeVelocityExtrapolationPath(drawnPath, Math.max(50, Math.min(200, Math.round((pathToDraw.length||80)*1.0))));
                    const velEnd = velEx.length ? velEx[velEx.length - 1] : last;
                    // 候選機場：距離最後點 600km 以內
                    const cand = [];
                    for (const ap of airportsIndex) {
                        const dkm = haversineKm(last, ap);
                        if (dkm <= 600) cand.push({ ap, dLast: dkm });
                    }
                    // 從後端補齊「附近機場」以避免前端索引缺漏（取 end 或 last 周邊）
                    try {
                        const endRef = (pathToDraw && pathToDraw.length) ? pathToDraw[pathToDraw.length-1] : last;
                        const q = new URLSearchParams({ lat: String(endRef.lat), lng: String(endRef.lng), k: '8', airport_only: 'true', require_iata: 'false' });
                        const resp = await fetch('/api/openflights/nearest-airports?' + q.toString());
                        if (resp.ok) {
                            const arr = await resp.json();
                            if (Array.isArray(arr)) {
                                for (const it of arr) {
                                    const exists = cand.some(c => ((c.ap.iata||'') && (c.ap.iata||'') === (it.iata||'')) || ((c.ap.icao||'') && (c.ap.icao||'') === (it.icao||'')));
                                    if (!exists && isFinite(it.lat) && isFinite(it.lng)) {
                                        cand.push({ ap: { iata: it.iata, icao: it.icao, name: it.name, lat: it.lat, lng: it.lng }, dLast: haversineKm(last, it) });
                                    }
                                }
                            }
                        }
                    } catch(_){ /* 忽略後端不可用的情況 */ }
                    // 如果在東京附近，確保 NRT/HND 在候選
                    const ensureIata = (code) => {
                        const idx = airportsIndex.findIndex(a => (a.iata||'').toUpperCase() === code);
                        if (idx >= 0 && !cand.some(c => (c.ap.iata||'') === code)) {
                            cand.push({ ap: airportsIndex[idx], dLast: haversineKm(last, airportsIndex[idx]) });
                        }
                    };
                    ensureIata('NRT'); ensureIata('HND');
                    // 方向一致性：使用最近段平均方位與機場方位夾角
                    const recentN = Math.min(6, drawnPath.length - 1);
                    let sx=0, sy=0, stepSum=0;
                    for (let i = drawnPath.length - recentN - 1; i < drawnPath.length - 1; i++) {
                        const a = drawnPath[i], b = drawnPath[i+1];
                        stepSum += haversineKm(a, b);
                        const bd = bearingDeg(a, b);
                        sx += Math.cos(bd*Math.PI/180); sy += Math.sin(bd*Math.PI/180);
                    }
                    const avgBr = (Math.atan2(sy, sx) * 180/Math.PI + 360)%360;
                    // 來自 Top-5 的加權目的地中心（若有）
                    const center = weightedDestCenter;
                    // 若已非常接近某機場（以最後點為準），直接優先考慮吸附
                    let closest = null; let minD = Number.POSITIVE_INFINITY;
                    for (const c of cand) { if (c.dLast < minD) { minD = c.dLast; closest = c; } }
                    // 近距離閾值依平均步距調整（2~12km）
                    const avgStepKm = stepSum / Math.max(1, recentN);
                    const nearKm = Math.max(2, Math.min(12, (avgStepKm||3)*2));
                    // 評分：距離、方向、速度外推對準、與中心一致性
                    const items = cand.map(c => {
                        const ap = c.ap;
                        const dPred = (pathToDraw.length ? haversineKm(pathToDraw[pathToDraw.length-1], ap) : c.dLast);
                        const dVel = haversineKm(velEnd, ap);
                        const brToAp = bearingDeg(last, ap);
                        const ang = angleDiffDeg(avgBr, brToAp);
                        const centerBonus = center ? Math.max(0, 1 - Math.min(1, haversineKm(center, ap)/400)) : 0; // 400km 內加分
                        const sNear = 1 / (1 + Math.max(0, c.dLast)/20); // 距離最後點的貼近分
                        // 轉成 0~1 分數：距離反比、角度隨相差遞減
                        const sDist = 1 / (1 + Math.max(0, dPred)/150);
                        const sVel = 1 / (1 + Math.max(0, dVel)/200);
                        const sAngle = Math.max(0, 1 - (ang/90)); // 0度=1, 90度=0, 180度=負→截斷為0
                        const s = 0.40*sDist + 0.25*sAngle + 0.20*sVel + 0.10*sNear + 0.05*centerBonus;
                        return { ap, s, dLast: c.dLast };
                    });
                    // 正規化為百分比
                    const sumS = items.reduce((a, x) => a + Math.max(0, x.s), 0) || 1;
                    predictedAirportScores = items.map(x => ({ ap: x.ap, prob: Math.max(0, x.s)/sumS }));
                    predictedAirportScores.sort((a,b) => b.prob - a.prob);
                    let best = predictedAirportScores[0];
                    const forceNear = (closest && isFinite(minD) && minD <= nearKm);
                    if ((best && best.prob > 0.2) || forceNear) { // 接近時放寬條件
                        // 額外條件：若距離很遠且角度偏差大，避免直接吸附（以免「走過頭再折返」視覺）
                        const end = pathToDraw.length ? pathToDraw[pathToDraw.length-1] : last;
                        const pickAp = forceNear ? closest.ap : best.ap;
                        const dkm = haversineKm(end, pickAp);
                        const brAvg = avgBr;
                        const brToAp = bearingDeg(end, pickAp);
                        const dang = angleDiffDeg(brAvg, brToAp);
                        const okSnap = forceNear || (dkm <= 80) || (dang <= 45) || (best.prob >= 0.45);
                        if (okSnap) {
                            predictedNearestAirport = pickAp;
                            // 近距離且角度合理時，直接走直線到機場，避免迴旋
                            const directMode = forceNear || ((dkm <= 60) && (dang <= 60 || best.prob >= 0.35));
                            if (directMode) {
                                pathToDraw = [ { lat: last.lat, lng: last.lng }, { lat: pickAp.lat, lng: pickAp.lng } ];
                            } else {
                                // 一般情況：保留預測，若末端距離機場仍大於 2km，補一個機場終點點
                                if (dkm > 2) pathToDraw.push({ lat: pickAp.lat, lng: pickAp.lng });
                            }
                            // 保守修剪：如果距離機場的序列出現明顯增加，裁切到首次增加點避免「過頭再折返」
                            try {
                                if (pathToDraw && pathToDraw.length >= 3) {
                                    const ap = pickAp;
                                    let prev = haversineKm(pathToDraw[0], ap);
                                    let cut = -1;
                                    for (let i=1; i<pathToDraw.length; i++) {
                                        const d = haversineKm(pathToDraw[i], ap);
                                        if (d > prev + 1.0) { cut = i; break; }
                                        prev = d;
                                    }
                                    if (cut >= 0) {
                                        pathToDraw = pathToDraw.slice(0, cut);
                                        if (haversineKm(pathToDraw[pathToDraw.length-1], ap) > 2) {
                                            pathToDraw.push({ lat: ap.lat, lng: ap.lng });
                                        }
                                    }
                                }
                            } catch(_){}
                        }
                    }
                    // 更新詳細面板：顯示前 5 個機場的百分比
                    const destDetails = document.getElementById('destDetails');
                    if (destDetails && predictedAirportScores && predictedAirportScores.length) {
                        const topN = predictedAirportScores.slice(0, 5);
                        // 清空舊的（保留 updateDestinationEstimates 生成的部分之前，插入一段機率列表）
                        const block = document.createElement('li');
                        block.style.fontSize = '12px';
                        block.style.opacity = '0.95';
                        block.innerHTML = '機場機率：' + topN.map(x => {
                            const label = (x.ap.iata||x.ap.icao||'UNK') + (x.ap.name?(' '+x.ap.name):'');
                            return `${label} ${(x.prob*100).toFixed(1)}%`;
                        }).join(' · ');
                        destDetails.prepend(block);
                    }
                }
            } catch (e) { console.warn('airport scoring failed', e); }
            const predictedPath = new google.maps.Polyline({
                path: pathToDraw,
                geodesic: false,
                strokeColor: '#ff6b6b',
                strokeOpacity: 1.0,
                strokeWeight: 4,
                icons: [{
                    icon: { path: google.maps.SymbolPath.FORWARD_CLOSED_ARROW, scale: 4, strokeColor: '#ff6b6b' },
                    offset: '100%'
                }]
            });
            predictedPath.setMap(map);
            // 讓清除功能可移除預測線
            flightPaths.push(predictedPath);
            // 更新預測終點標記（黃色），確保與路徑對齊
            predictedLastPoint = pathToDraw[pathToDraw.length - 1] || null;
            if (destinationMarker) { destinationMarker.setMap(null); destinationMarker = null; }
            if (predictedLastPoint) {
                destinationMarker = new google.maps.Marker({
                    position: predictedLastPoint,
                    map: map,
                    icon: {
                        path: google.maps.SymbolPath.CIRCLE,
                        scale: 7,
                        fillColor: '#ffd54f',
                        fillOpacity: 0.95,
                        strokeWeight: 2,
                        strokeColor: '#000'
                    },
                    title: (() => {
                        if (!predictedNearestAirport) return `預測終點 (${predictedLastPoint.lat.toFixed(3)}, ${predictedLastPoint.lng.toFixed(3)})`;
                        let pct = '';
                        if (predictedAirportScores && predictedAirportScores.length && predictedAirportScores[0].ap === predictedNearestAirport) {
                            pct = ` ${(predictedAirportScores[0].prob*100).toFixed(1)}%`;
                        }
                        return `預測終點（對齊機場 ${predictedNearestAirport.iata||predictedNearestAirport.icao||''} ${predictedNearestAirport.name||''}${pct}）`;
                    })()
                });
            }
            // 同步摘要顯示
            refreshDestinationSummary();
        }

        // 顯示目前演算法的 Top 5 線段到地圖（若已有結果）
        function showTopFiveNow() {
            let results = null;
            if (multiAlgorithmResults && multiAlgorithmResults[currentAlgorithm]) {
                results = multiAlgorithmResults[currentAlgorithm];
            } else if (predictionResults && predictionResults[currentAlgorithm] && predictionResults[currentAlgorithm].results) {
                results = predictionResults[currentAlgorithm].results;
            }
            if (!results || !results.length) {
                alert('目前沒有可用的 Top 5 結果，請先執行分析。');
                return;
            }
            displaySimilarFlights(results);
            updateTopFiveList(results, currentAlgorithm);
        }

    // （已移除）Top 1 續航示範功能

        // 貝葉斯優化
        function runBayesianOptimization() {
            updateStatus('🧠 啟動貝葉斯優化自動調參…');
            const btn = document.querySelector('.optimization-btn');
            const original = btn.textContent; btn.disabled = true; btn.textContent = '🔄 優化中…';
            showProgress(true);
            startLocalETA(30, '優化參數');
            fetch('/api/optimize-parameters', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ n_calls: 30 })
            })
            .then(r => { if (!r.ok) throw new Error(`優化 API 錯誤: ${r.status}`); return r.json(); })
            .then(res => {
                if (res.optimization_complete) {
                    updateStatus(`✅ 貝葉斯優化完成，最佳分數: ${Number(res.best_score).toFixed(4)}`);
                    alert(`🎉 貝葉斯優化完成！\n最佳分數: ${Number(res.best_score).toFixed(4)}\n優化輪數: ${res.optimization_calls}`);
                } else {
                    updateStatus('❌ 貝葉斯優化未完成');
                }
            })
            .catch(err => { updateStatus(`❌ 優化失敗: ${err.message}`); console.error(err); })
            .finally(() => { btn.disabled = false; btn.textContent = original; hideProgress(); });
        }

        function displaySimilarFlights(results) {
            // 僅清除上一組 Top5 視覺化，不影響其他已繪製的航線或預測
            if (currentTopFiveIds && currentTopFiveIds.length) {
                currentTopFiveIds.forEach(fid => {
                    if (topFivePolylineMap[fid]) { topFivePolylineMap[fid].setMap(null); delete topFivePolylineMap[fid]; }
                    if (topFiveStartMarkers[fid]) { topFiveStartMarkers[fid].setMap(null); delete topFiveStartMarkers[fid]; }
                });
                currentTopFiveIds = [];
                highlightedFlightId = null;
            }
            updateStatus(`🔍 顯示 ${results.length} 個相似航班...`);
            // 為了在標記上顯示百分比，先用 Top-5 的相對權重（1/score）經 softmax 轉換
            const topK = Math.min(5, results.length);
            const scoresK = results.slice(0, topK).map(r => (Number(r.score)||0));
            const weights = weightsFromScores(scoresK);
            let sf = softmax(weights, 0.8);
            sf = emphasizePercents(sf);
            const idToPct = {};
            for (let i=0;i<topK;i++) {
                const fid = results[i].flight;
                const pct = Math.max(0, Math.min(100, (sf[i]||0)*100));
                idToPct[fid] = pct;
            }
            const colors = ['#ff4444', '#44ff44', '#4444ff', '#ffff44', '#ff44ff', '#44ffff', '#ff8844'];
            results.forEach((result, index) => {
                if (index >= 5) return; // 只顯示前5個最相似的
                const flightId = result.flight;
                currentTopFiveIds.push(flightId);
                // 從後端獲取該航班的完整路徑（需編碼避免特殊字元失敗）
                fetch(`/api/flight/${encodeURIComponent(flightId)}`)
                    .then(response => response.json())
                    .then(flightData => {
                        if (flightData.coordinates && flightData.coordinates.length >= 2) {
                            const color = colors[index % colors.length];
                            const path = normalizePathCoords(flightData.coordinates);
                            // 航線
                            const poly = new google.maps.Polyline({
                                path: path,
                                geodesic: true,
                                strokeColor: color,
                                strokeOpacity: 0.85,
                                strokeWeight: 3
                            });
                            poly.setMap(map);
                            topFivePolylineMap[flightId] = poly;
                            // 起點標記
                            const startMarker = new google.maps.Marker({
                                position: path[0],
                                map: map,
                                icon: {
                                    path: google.maps.SymbolPath.CIRCLE,
                                    scale: 8,
                                    fillColor: color,
                                    fillOpacity: 0.9,
                                    strokeWeight: 2,
                                    strokeColor: '#ffffff'
                                },
                                title: (() => {
                                    const pct = (idToPct[flightId] != null) ? idToPct[flightId].toFixed(1) + '%' : '';
                                    return `相似航班: ${formatFlightName(flightId, flightData)}\n相似度: ${pct}`;
                                })()
                            });
                            topFiveStartMarkers[flightId] = startMarker;
                        }
                    })
                    .catch(error => {
                        console.error(`無法載入航班 ${flightId}:`, error);
                    });
            });
        }

        function calculateRealAccuracy(results) {
            // 基於真實相似度分數計算準確率
            if (!results || results.length === 0) return 0;
            
            const avgScore = results.reduce((sum, r) => sum + (100 - r.score), 0) / results.length;
            return Math.max(0, Math.min(100, avgScore));
        }

        function displayPrediction(predictionPath, algorithm) {
            const colors = {
                'dtw': '#ff4444', 'lcss': '#44ff44', 'euclidean': '#4444ff',
                'frechet': '#ff44ff', 'hausdorff': '#ffff44', 'edr': '#44ffff', 'erp': '#ff8844'
            };
            
            const predictionPolyline = new google.maps.Polyline({
                path: predictionPath,
                geodesic: true,
                strokeColor: colors[algorithm],
                strokeOpacity: 0.8,
                strokeWeight: 4
            });
            
            predictionPolyline.setMap(map);
            flightPaths.push(predictionPolyline);
            
            // 終點標記
            new google.maps.Marker({
                position: predictionPath[predictionPath.length - 1],
                map: map,
                icon: {
                    path: google.maps.SymbolPath.CIRCLE,
                    scale: 8,
                    fillColor: colors[algorithm],
                    fillOpacity: 0.8,
                    strokeWeight: 2,
                    strokeColor: '#ffffff'
                },
                title: `${getAlgorithmName(algorithm)} 預測終點`
            });
        }

        function clearPredictions() {
            // 清除預測路線（保留航班數據）
            flightPaths.forEach(path => { path.setMap(null); });
            flightPaths = [];
            // 也清除目前 Top5 的航線與標記
            if (currentTopFiveIds && currentTopFiveIds.length) {
                currentTopFiveIds.forEach(fid => {
                    if (topFivePolylineMap[fid]) { topFivePolylineMap[fid].setMap(null); delete topFivePolylineMap[fid]; }
                    if (topFiveStartMarkers[fid]) { topFiveStartMarkers[fid].setMap(null); delete topFiveStartMarkers[fid]; }
                });
                currentTopFiveIds = [];
                highlightedFlightId = null;
            }
            // 清空 Top5 清單內容與標籤，顯示空狀態
            try {
                const list = document.getElementById('topFiveList');
                const empty = document.getElementById('topFiveEmpty');
                const label = document.getElementById('topFiveAlgoLabel');
                if (list) list.innerHTML = '';
                if (empty) empty.style.display = 'block';
                if (label) label.textContent = '(沒有結果)';
            } catch (_) {}
            // 重置快取，避免舊資料再次顯示
            predictionResults = {};
            multiAlgorithmResults = {};
            updateStatus('🗑️ 已清除所有預測結果');
            // 清除終點標記與摘要
            if (destinationMarker) { destinationMarker.setMap(null); destinationMarker = null; }
            predictedLastPoint = null; weightedDestCenter = null;
            const destSummary = document.getElementById('destSummary');
            const destDetails = document.getElementById('destDetails');
            if (destSummary) destSummary.textContent = '尚未分析';
            if (destDetails) destDetails.innerHTML = '';
        }

        function comparePredictions() {
            // 合併多來源結果（單一演算法分析 + 一次跑七種演算法）
            const combined = {};
            if (multiAlgorithmResults) {
                Object.keys(multiAlgorithmResults).forEach(k => {
                    const kk = (k || '').toLowerCase();
                    const arr = multiAlgorithmResults[k] || [];
                    if (arr && arr.length) combined[kk] = { results: arr };
                });
            }
            if (predictionResults) {
                Object.keys(predictionResults).forEach(k => {
                    const kk = (k || '').toLowerCase();
                    const entry = predictionResults[k];
                    if (entry && Array.isArray(entry.results) && entry.results.length) combined[kk] = { results: entry.results };
                });
            }
            const keys = Object.keys(combined);
            if (!keys.length) { alert('⚠️ 請先執行一些分析！'); return; }

            let comparison = `📊 分析結果比較 (共 ${keys.length} 個演算法):\n\n`;
            keys.forEach(alg => {
                const arr = combined[alg].results || [];
                const resultCount = arr.length;
                const avgScore = resultCount ? (arr.reduce((s, r) => s + (Number(r.score) || 0), 0) / resultCount).toFixed(2) : 'N/A';
                comparison += `${getAlgorithmName(alg)}: 找到 ${resultCount} 個相似航班，平均分數: ${avgScore}\n`;
            });
            alert(comparison);
        }

    function getAlgorithmName(algorithm) {
            const names = {
                'dtw': 'DTW (動態時間規整)', 'lcss': 'LCSS ',
                'euclidean': 'Euclidean Distance', 'frechet': 'Fréchet Distance',
        'hausdorff': 'Hausdorff Distance', 'edr': 'EDR ', 'erp': 'ERP ',
        'subseq_dtw': 'Subsequence DTW'
            };
            return names[algorithm] || algorithm;
        }

        // 滑動條事件
        (function(){
            const slider = document.getElementById('flightCountSlider');
            if (slider) slider.addEventListener('input', updateSliderDisplay);
        })();

        // 點擊視窗外關閉modal
        window.onclick = function(event) {
            const modal = document.getElementById('algorithmModal');
            if (event.target === modal) {
                closeAlgorithmModal();
            }
        }
    </script>

    <script>
        // 路徑工具：座標正規化/去除重複點
        function toLatLng(p) {
            if (!p) return null;
            const lat = (p.lat != null) ? p.lat : p.latitude;
            const lng = (p.lng != null) ? p.lng : p.longitude;
            if (typeof lat !== 'number' || typeof lng !== 'number' || isNaN(lat) || isNaN(lng)) return null;
            return { lat, lng };
        }
        function normalizePathCoords(coords) {
            if (!coords) return [];
            const out = [];
            const flat = (node) => {
                if (!node) return;
                if (Array.isArray(node)) {
                    for (const v of node) flat(v);
                } else if (typeof node === 'object' && Array.isArray(node.coordinates)) {
                    flat(node.coordinates);
                } else if (typeof node === 'object') {
                    const p = toLatLng(node);
                    if (p) out.push(p);
                }
            };
            flat(coords);
            // 去除相鄰重覆點（<10m）
            const dedup = [];
            for (let i = 0; i < out.length; i++) {
                if (i === 0) { dedup.push(out[i]); continue; }
                const prev = dedup[dedup.length - 1];
                const cur = out[i];
                if (haversineKm(prev, cur) < 0.01) continue;
                dedup.push(cur);
            }
            return dedup;
        }

        // 機場索引：嘗試載入外部 JSON，或 DAFIF .dat，不行則使用內建少量清單
        function parseDafifDat(text) {
            try {
                const lines = (text||'').split(/\r?\n/).map(s => s.trim()).filter(Boolean);
                const out = [];
                for (const line of lines) {
                    // 格式: CC,Name,ICAO,IATA,lon,lat,elev
                    const parts = line.split(',');
                    if (parts.length < 6) continue;
                    const cc = parts[0];
                    const name = parts[1];
                    const icao = parts[2];
                    const iata = parts[3] || '';
                    const lon = Number(parts[4]);
                    const lat = Number(parts[5]);
                    if (!isFinite(lat) || !isFinite(lon)) continue;
                    out.push({ iata: iata || undefined, icao: icao || undefined, name, lat, lng: lon });
                }
                return out;
            } catch (_) { return []; }
        }
        async function preloadAirports() {
            try {
                const tryPaths = ['/airports.json', '/data/airports.json', '/airports-dafif.json'];
                for (const p of tryPaths) {
                    try {
                        const r = await fetch(p);
                        if (r.ok) {
                            const j = await r.json();
                            if (Array.isArray(j) && j.length) { airportsIndex = j; updateStatus(`🗺️ 已載入機場索引 (${j.length})`); return; }
                        }
                    } catch (_) {}
                }
                // 嘗試 DAFIF 純文字檔（多種可能路徑）
                const dafifPaths = ['/airports-dafif.dat', 'airports-dafif.dat', '/data/airports-dafif.dat'];
                for (const p of dafifPaths) {
                    try {
                        const r2 = await fetch(p);
                        if (r2.ok) {
                            const txt = await r2.text();
                            const arr = parseDafifDat(txt);
                            if (arr.length) { airportsIndex = arr; updateStatus(`🗺️ 已載入機場索引 (DAFIF ${arr.length})`); return; }
                        }
                    } catch (_) {}
                }
            } catch (_) {}
            airportsIndex = (typeof builtinAirports !== 'undefined' && Array.isArray(builtinAirports)) ? builtinAirports.slice() : [];
            if (airportsIndex.length) updateStatus('🗺️ 使用內建機場清單（示例）');
        }

        function findNearestAirport(point, maxKm = 300) {
            if (!point || !airportsIndex || !airportsIndex.length) return null;
            let best = null, bestD = Number.POSITIVE_INFINITY;
            for (const ap of airportsIndex) {
                const d = haversineKm(point, ap);
                if (d < bestD) { bestD = d; best = ap; }
            }
            if (!isFinite(bestD) || bestD > maxKm) return null;
            return best;
        }
    </script>

    <script async defer
        src="https://maps.googleapis.com/maps/api/js?key=AIzaSyB2rNDbGRGTVubn0aQw2NZP38UH_igS3LU&libraries=drawing&callback=initMap">
    </script>
</body>
</html>
