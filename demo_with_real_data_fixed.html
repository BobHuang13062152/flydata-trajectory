<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ğŸ›« èˆªç­è»Œè·¡åˆ†æ - çœŸå¯¦æ•¸æ“šæ¼”ç¤º</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);
            color: #fff;
        }
        
        .header {
            background: rgba(0,0,0,0.3);
            padding: 15px 20px;
            text-align: center;
        }
        
        .container {
            display: flex;
            height: calc(100vh - 70px);
        }
        
        .sidebar {
            width: 300px;
            background: rgba(255,255,255,0.1);
            padding: 20px;
            overflow-y: auto;
            backdrop-filter: blur(10px);
        }
        
        .map-container {
            flex: 1;
            position: relative;
        }
        
        #map {
            width: 100%;
            height: 100%;
        }
        
        .status {
            position: absolute;
            bottom: 20px;
            right: 20px;
            background: rgba(0,0,0,0.8);
            padding: 10px;
            border-radius: 10px;
            font-size: 14px;
            z-index: 1000;
            max-width: 300px;
        }
        
        button {
            width: 100%;
            padding: 10px;
            margin: 5px 0;
            border: none;
            border-radius: 5px;
            background: #42a5f5;
            color: white;
            cursor: pointer;
            font-size: 14px;
        }
        
        button:hover {
            background: #1e88e5;
        }
        
        .flight-count-control {
            background: rgba(255,255,255,0.1);
            padding: 15px;
            border-radius: 8px;
            margin: 10px 0;
        }
        
        input[type="range"] {
            width: 100%;
            margin: 10px 0;
        }
        
        .quick-buttons {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 5px;
            margin-top: 10px;
        }
        
        .quick-buttons button {
            font-size: 10px;
            padding: 5px;
            margin: 1px;
        }
        
        /* å°å‹æ¼”ç®—æ³•è¦–çª— */
        .algorithm-modal {
            display: none;
            position: fixed;
            z-index: 3000;
            right: 20px;
            top: 50%;
            transform: translateY(-50%);
            width: 280px;
            background: linear-gradient(135deg, #1e3c72, #2a5298);
            border-radius: 10px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.5);
            border: 2px solid rgba(255,255,255,0.2);
        }
        
        .algorithm-header {
            padding: 15px;
            border-bottom: 1px solid rgba(255,255,255,0.1);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .algorithm-header h3 {
            color: #64b5f6;
            font-size: 16px;
        }
        
        .close-btn {
            background: none;
            border: none;
            color: white;
            font-size: 20px;
            cursor: pointer;
            padding: 0;
            width: auto;
        }
        
        /* æ–°å¢ï¼šå¢å¼·åŠŸèƒ½æ¨£å¼ï¼ˆå­¸ç¿’ MATLAB ç•Œé¢è¨­è¨ˆï¼‰ */
        .enhancement-section {
            margin-top: 20px;
            padding-top: 15px;
            border-top: 1px solid rgba(255,255,255,0.1);
        }
        
        .enhancement-controls {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }
        
        .enhancement-item {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 8px;
            border-radius: 8px;
            background: rgba(255,255,255,0.05);
        }
        
        .enhancement-info {
            flex: 1;
        }
        
        .enhancement-name {
            font-weight: 600;
            color: #64b5f6;
            font-size: 14px;
        }
        
        .enhancement-desc {
            font-size: 12px;
            color: rgba(255,255,255,0.7);
            margin-top: 2px;
        }
        
        /* åˆ‡æ›é–‹é—œæ¨£å¼ */
        .switch {
            position: relative;
            display: inline-block;
            width: 44px;
            height: 24px;
        }
        
        .switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }
        
        .slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: rgba(255,255,255,0.2);
            transition: .3s;
            border-radius: 24px;
        }
        
        .slider:before {
            position: absolute;
            content: "";
            height: 18px;
            width: 18px;
            left: 3px;
            bottom: 3px;
            background-color: white;
            transition: .3s;
            border-radius: 50%;
        }
        
        input:checked + .slider {
            background-color: #64b5f6;
        }
        
        input:checked + .slider:before {
            transform: translateX(20px);
        }
        
        /* å„ªåŒ–æŒ‰éˆ•æ¨£å¼ */
        .optimization-btn {
            background: linear-gradient(135deg, #ff6b6b, #ee5a5a);
            border: none;
            color: white;
            padding: 8px 16px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 12px;
            font-weight: 600;
            transition: all 0.3s;
            width: 100%;
        }
        
        .optimization-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(255,107,107,0.3);
        }
        
        .optimization-controls {
            display: flex;
            flex-direction: column;
            gap: 6px;
        }
        
        .algorithm-list {
            padding: 15px;
            max-height: 300px;
            overflow-y: auto;
        }
        
        .algorithm-item {
            background: rgba(255,255,255,0.1);
            margin: 8px 0;
            padding: 10px;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.3s;
            border: 1px solid transparent;
        }
        
        .algorithm-item:hover {
            background: rgba(66,165,245,0.3);
            border-color: #42a5f5;
        }
        
        .algorithm-item.selected {
            background: rgba(76,175,80,0.3);
            border-color: #4caf50;
        }
        
        .algorithm-name {
            font-weight: bold;
            font-size: 13px;
            color: #81c784;
        }
        
        .algorithm-accuracy {
            font-size: 11px;
            opacity: 0.8;
            margin-top: 3px;
        }
        
        .algorithm-controls {
            padding: 15px;
            border-top: 1px solid rgba(255,255,255,0.1);
        }
        
        .algorithm-controls button {
            margin: 2px 0;
            font-size: 12px;
            padding: 8px;
        }
        
        .predict-btn { background: #4caf50; }
        .clear-btn { background: #f44336; }
        .compare-btn { background: #ff9800; }

    /* é€²åº¦æ¢ UIï¼ˆæ”¯æ´å¤šä»»å‹™ï¼Œä¸»è¦é€²åº¦ç½®é ‚å¤§æ¢ï¼Œå…¶é¤˜å°æ¢å †ç–Šï¼‰ */
    .progress-container {
            position: absolute;
            bottom: 70px;
            right: 20px;
            width: 300px;
            background: rgba(0,0,0,0.8);
            padding: 10px;
            border-radius: 10px;
            z-index: 1001;
        }
    .progress-item { margin-top: 8px; }
    .progress-item:first-child { margin-top: 0; }
    .pi-header { display: flex; justify-content: space-between; align-items: center; font-size: 12px; color: #fff; opacity: .9; margin-bottom: 4px; }
    .pi-label { font-weight: 600; }
    .pi-meta { opacity: .9; }
    .pi-bar { width: 100%; background: rgba(255,255,255,0.12); border-radius: 6px; overflow: hidden; }
    .pi-fill { height: 100%; width: 0%; background: linear-gradient(90deg, #42a5f5, #64b5f6); transition: width .3s ease; }
    .progress-item.primary .pi-bar { height: 12px; }
    .progress-item.secondary .pi-bar { height: 6px; opacity: 0.95; }
    .pi-fill.indeterminate { width: 30%; animation: indet 1.2s infinite ease-in-out; }
        @keyframes indet {
            0% { margin-left: 0%; }
            50% { margin-left: 70%; }
            100% { margin-left: 0%; }
        }
    .progress-secondary-wrap { margin-top: 8px; max-height: 180px; overflow-y: auto; }
    </style>
</head>
<body>
    <div class="header">
        <h1>ğŸ›« æ°‘èˆªæ©Ÿè»Œè·¡é æ¸¬åˆ†æç³»çµ±</h1>
        <p>ğŸ“Š èˆªç­è»Œè·¡æ•¸é‡:157313ç­† | ğŸ¯ å¤šç¨®æ¼”ç®—æ³•é æ¸¬</p>
    </div>
    
    <div class="container">
        <div class="sidebar">
            <h2>ğŸ›ï¸ æ§åˆ¶é¢æ¿</h2>
            
            <div class="flight-count-control">
                <h3>âœˆï¸ èˆªç­æ•¸é‡</h3>
                <p>ç•¶å‰: <span id="flightCountDisplay">50</span></p>
                <input type="range" id="flightCountSlider" min="5" max="200000" value="50" step="5">
                
                <div class="quick-buttons">
                    <button onclick="setFlightCount(100)">100</button>
                    <button onclick="setFlightCount(1000)">1K</button>
                    <button onclick="setFlightCount(10000)">10K</button>
                    <button onclick="setFlightCount(50000)">50K</button>
                    <button onclick="setFlightCount(150000)">150K</button>
                    <button onclick="setFlightCount(157313)">ALL</button>
                </div>
            </div>
            
            <button onclick="loadFlightData()">ğŸ“‚ è¼‰å…¥èˆªç­æ•¸æ“š</button>
            <button onclick="showAllFlights()">ğŸ—ºï¸ é¡¯ç¤ºèˆªç·š</button>
            <button onclick="hideAllFlights()">ğŸš« éš±è—èˆªç·š</button>
            <button onclick="testBackend()">ğŸ”§ æ¸¬è©¦å¾Œç«¯</button>
            <button onclick="openAlgorithmModal()" style="background: #4caf50; font-weight: bold;">ğŸ¯ å¤šæ¼”ç®—æ³•é æ¸¬</button>

            <div class="enhancement-section">
                <h3>ğŸš€ å¢å¼·åŠŸèƒ½</h3>
                <div class="enhancement-controls">
                    <div class="enhancement-item">
                        <label class="switch">
                            <input type="checkbox" id="fastMode" checked>
                            <span class="slider"></span>
                        </label>
                        <div class="enhancement-info">
                            <div class="enhancement-name">âš¡ Fast Mode</div>
                            <div class="enhancement-desc">åŠ é€Ÿåˆ†æï¼ˆé™æ¡æ¨£/å­åºåˆ—/æ­¥å¹…ï¼‰</div>
                        </div>
                    </div>
                    <!-- LSTM æ‰‹å‹•æ§åˆ¶ï¼šåƒ…åœ¨æŒ‰éˆ•è§¸ç™¼æ™‚åŸ·è¡Œï¼Œä¸è‡ªå‹•åŸ·è¡Œ -->
                    <div class="enhancement-item">
                        <label class="switch" title="å•Ÿç”¨ LSTM æ‰‹å‹•æ¨¡å¼">
                            <input type="checkbox" id="enableLSTM">
                            <span class="slider"></span>
                        </label>
                        <div class="enhancement-info">
                            <div class="enhancement-name">ğŸ§  LSTM æ‰‹å‹•</div>
                            <div class="enhancement-desc">ä¸è‡ªå‹•ï¼›åƒ…æŒ‰ä¸‹æ–¹æŒ‰éˆ•æ™‚åŸ·è¡Œ</div>
                        </div>
                    </div>
                    <div class="lstm-controls" style="margin: 6px 0 10px 44px;">
                        <div style="display:flex; align-items:center; gap:8px; margin-bottom:6px;">
                            <label for="lstmHorizon" style="font-size:12px; opacity:.85;">æ­¥æ•¸</label>
                            <input type="range" id="lstmHorizon" min="1" max="300" step="5" value="80" style="flex:1;">
                            <span id="lstmHorizonDisplay" style="width:42px; text-align:right; font-size:12px; opacity:.9;">80</span>
                            <label class="switch" title="è‡ªå‹•æ±ºå®šæ­¥æ•¸">
                                <input type="checkbox" id="lstmAutoHorizon" checked>
                                <span class="slider"></span>
                            </label>
                            <span style="font-size:12px; opacity:.85;">è‡ªå‹•</span>
                        </div>
                        <button class="optimization-btn" onclick="runLSTMNow()">â–¶ åŸ·è¡Œ LSTM é æ¸¬</button>
                    </div>
                    <div class="optimization-controls">
                        <button class="optimization-btn" onclick="runBayesianOptimization()">ğŸ§  è²è‘‰æ–¯å„ªåŒ–</button>
                        <div class="enhancement-desc">è‡ªå‹•èª¿æ•´æœ€ä½³åƒæ•¸</div>
                    </div>
                </div>
            </div>

            <div id="topFivePanel" style="margin-top: 16px; padding: 12px; background: rgba(255,255,255,0.06); border-radius: 8px;">
                <div style="display:flex; justify-content:space-between; align-items:center;">
                    <h3 style="font-size: 16px; color:#64b5f6;">ğŸ† Top five most similar flights</h3>
                    <span id="topFiveAlgoLabel" style="font-size:12px; opacity:0.8;">(å°šæœªåˆ†æ)</span>
                </div>
                <ul id="topFiveList" style="list-style:none; margin-top:10px; display:grid; gap:8px; padding:0;"></ul>
                <div id="topFiveEmpty" style="font-size:12px; opacity:0.8;">è«‹å…ˆåŸ·è¡Œåˆ†æä¾†é¡¯ç¤ºçµæœ</div>
            </div>

            <div id="explainPanel" style="margin-top: 12px; padding: 12px; background: rgba(255,255,255,0.06); border-radius: 8px;">
                <h3 style="font-size: 16px; color:#aed581;">ğŸ§­ ç›®çš„åœ°æ¨ä¼° / åˆ†æåŸå› </h3>
                <div id="destSummary" style="font-size: 12px; opacity: 0.9; margin-top:6px;">å°šæœªåˆ†æ</div>
                <ul id="destDetails" style="list-style: none; padding: 0; margin-top: 8px; display: grid; gap: 6px;"></ul>
            </div>
            
            <div style="margin-top: 20px; padding: 10px; background: rgba(255,255,255,0.05); border-radius: 5px; font-size: 12px;">
                <p><strong>ä½¿ç”¨èªªæ˜ï¼š</strong></p>
                <p>1. è¼‰å…¥èˆªç­æ•¸æ“š</p>
                <p>2. èª¿æ•´é¡¯ç¤ºæ•¸é‡</p>
                <p>3. åœ¨åœ°åœ–ä¸Šç¹ªè£½è»Œè·¡</p>
                <p>4. ä½¿ç”¨å¤šæ¼”ç®—æ³•é æ¸¬</p>
            </div>
        </div>
        
        <div class="map-container">
            <div id="map"></div>
            <div class="status" id="status">ğŸŸ¢ ç³»çµ±å°±ç·’</div>
            <div id="progressContainer" class="progress-container" style="display:none;">
                <div id="progressPrimary" class="progress-item primary">
                    <div class="pi-header"><span class="pi-label">è™•ç†ä¸­â€¦</span><span class="pi-meta">0% Â· ETA --</span></div>
                    <div class="pi-bar"><div class="pi-fill" style="width:0%"></div></div>
                </div>
                <div id="progressSecondary" class="progress-secondary-wrap"></div>
            </div>
        </div>
    </div>

    <!-- å°å‹æ¼”ç®—æ³•é¸æ“‡è¦–çª— -->
    <div id="algorithmModal" class="algorithm-modal">
        <div class="algorithm-header">
            <h3>ğŸ¯ æ¼”ç®—æ³•é¸æ“‡</h3>
            <button class="close-btn" onclick="closeAlgorithmModal()">&times;</button>
        </div>
        
        <div class="algorithm-list">
            <div class="algorithm-item" onclick="selectAlgorithm('dtw')" id="alg-dtw">
                <div class="algorithm-name">DTW å‹•æ…‹æ™‚é–“è¦æ•´</div>
                <div class="algorithm-accuracy">ç­‰å¾…è¨ˆç®—...</div>
            </div>

            <div class="algorithm-item" onclick="selectAlgorithm('subseq_dtw')" id="alg-subseq_dtw">
                <div class="algorithm-name">Subsequence DTW å­åºåˆ—DTW</div>
                <div class="algorithm-accuracy">é©åˆéƒ¨åˆ†è»Œè·¡</div>
            </div>
            
            <div class="algorithm-item" onclick="selectAlgorithm('lcss')" id="alg-lcss">
                <div class="algorithm-name">LCSS æœ€é•·å…¬å…±å­åºåˆ—</div>
                <div class="algorithm-accuracy">ç­‰å¾…è¨ˆç®—...</div>
            </div>
            
            <div class="algorithm-item" onclick="selectAlgorithm('euclidean')" id="alg-euclidean">
                <div class="algorithm-name">Euclidean Distance</div>
                <div class="algorithm-accuracy">ç­‰å¾…è¨ˆç®—...</div>
            </div>
            
            <div class="algorithm-item" onclick="selectAlgorithm('frechet')" id="alg-frechet">
                <div class="algorithm-name">FrÃ©chet Distance</div>
                <div class="algorithm-accuracy">ç­‰å¾…è¨ˆç®—...</div>
            </div>
            
            <div class="algorithm-item" onclick="selectAlgorithm('hausdorff')" id="alg-hausdorff">
                <div class="algorithm-name">Hausdorff Distance</div>
                <div class="algorithm-accuracy">ç­‰å¾…è¨ˆç®—...</div>
            </div>
            
            <div class="algorithm-item" onclick="selectAlgorithm('edr')" id="alg-edr">
                <div class="algorithm-name">EDR ç·¨è¼¯è·é›¢</div>
                <div class="algorithm-accuracy">ç­‰å¾…è¨ˆç®—...</div>
            </div>
            
            <div class="algorithm-item" onclick="selectAlgorithm('erp')" id="alg-erp">
                <div class="algorithm-name">ERP ç·¨è¼¯å¯¦æ•¸åºåˆ—</div>
                <div class="algorithm-accuracy">ç­‰å¾…è¨ˆç®—...</div>
            </div>

            <!-- é›†æˆç®—æ³•å·²ç§»é™¤ -->
        </div>
        
        <div class="algorithm-controls">
            <button class="compare-btn" style="background:#03a9f4" onclick="runAllAlgorithms()">âš¡ ä¸€æ¬¡è·‘ä¸ƒç¨®æ¼”ç®—æ³•</button>
            <button class="predict-btn" onclick="runPrediction()">ğŸš€ é–‹å§‹é æ¸¬</button>
            <button class="compare-btn" style="background:#2196f3" onclick="showTopFiveNow()">ğŸ† é¡¯ç¤º Top 5 èˆªç­</button>
            <button class="compare-btn" style="background:#00897b" onclick="toggleBBoxFilter()">ğŸ§± çŸ©å½¢ç¯„åœç¯©é¸</button>
            <button class="clear-btn" onclick="clearPredictions()">ğŸ—‘ï¸ æ¸…é™¤</button>
            <button class="compare-btn" onclick="comparePredictions()">ğŸ“Š æ¯”è¼ƒ</button>
        </div>
    </div>

    <script>
        let map;
        let drawingManager;
        let flightData = [];
        let allFlightData = [];
        let flightPaths = [];
        let drawnPath = [];
    let drawnPolyline = null; // ç›®å‰ç•«åœ¨åœ°åœ–ä¸Šçš„ä½¿ç”¨è€…ç¹ªè£½æŠ˜ç·š
        let currentFlightCount = 50;
        let currentAlgorithm = 'dtw';
        let predictionResults = {};
    let progressInterval = null;
    let multiAlgorithmResults = null;
    let bboxFilterEnabled = false;
    let bboxOverlay = null;
    let bboxStrictEnabled = false; // é è¨­ä¸å¼·åˆ¶ç«¯é»éƒ½åœ¨çŸ©å½¢å…§
    let minSpanRatio = 0.35; // é è¨­åŒ¹é…è·¨åº¦éœ€é”åˆ°æŸ¥è©¢è·¯å¾‘çš„ 35%
    // Top5 è¦–è¦ºåŒ–æŒä¹…åŒ–ï¼šä¿ç•™æ¯å€‹èˆªç­çš„ polyline èˆ‡èµ·é»æ¨™è¨˜ï¼Œä¾¿æ–¼é«˜äº®ä¸”ä¸æ¸…é™¤å…¶ä»–
    let topFivePolylineMap = {};   // flightId -> google.maps.Polyline
    let topFiveStartMarkers = {};  // flightId -> google.maps.Marker
    let currentTopFiveIds = [];    // ç›®å‰é¡¯ç¤ºåœ¨åœ°åœ–ä¸Šçš„ Top5 èˆªç­ ID é™£åˆ—
    let highlightedFlightId = null; // ç•¶å‰åŠ ç²—é«˜äº®çš„èˆªç­ ID
    let destinationMarker = null;   // ç›®çš„åœ°ï¼ˆèˆ‡é æ¸¬çµ‚é»å°é½Šï¼‰æ¨™è¨˜
    let localEtaTimer = null;       // æœ¬åœ° ETA è¨ˆæ™‚å™¨
    let predictedLastPoint = null;  // æœ€è¿‘ä¸€æ¬¡é æ¸¬è·¯å¾‘çš„çµ‚é»
    let predictedNearestAirport = null; // æœ€è¿‘ä¸€æ¬¡é æ¸¬çµ‚é»å°é½Šçš„æ©Ÿå ´ï¼ˆè‹¥æœ‰ï¼‰
    let predictedAirportScores = null;  // æœ€è¿‘ä¸€æ¬¡æ©Ÿå ´æ©Ÿç‡åˆ—è¡¨ [{ap, prob}]
    let weightedDestCenter = null;  // TopN åŠ æ¬Šç›®çš„åœ°ä¸­å¿ƒï¼ˆåƒ…ä½œç‚ºèªªæ˜ï¼Œä¸ä¸Šåœ°åœ–ï¼‰
    // æ©Ÿå ´ç´¢å¼•ï¼ˆå¯å¾å¤–éƒ¨ JSON è¼‰å…¥ï¼›è‹¥ç„¡å‰‡ä½¿ç”¨å…§å»ºç¤ºä¾‹ï¼‰
    let airportsIndex = null;
    const builtinAirports = [
        { iata: 'NRT', icao: 'RJAA', name: 'Tokyo Narita', lat: 35.772, lng: 140.392 },
        { iata: 'HND', icao: 'RJTT', name: 'Tokyo Haneda', lat: 35.553, lng: 139.781 },
        { iata: 'TPE', icao: 'RCTP', name: 'Taipei Taoyuan', lat: 25.079, lng: 121.232 },
        { iata: 'KIX', icao: 'RJBB', name: 'Osaka Kansai',  lat: 34.435, lng: 135.243 },
        { iata: 'HKG', icao: 'VHHH', name: 'Hong Kong',      lat: 22.308, lng: 113.918 },
        { iata: 'ICN', icao: 'RKSI', name: 'Seoul Incheon',  lat: 37.469, lng: 126.450 },
        { iata: 'NGO', icao: 'RJGG', name: 'Chubu Centrair', lat: 34.858, lng: 136.805 },
        { iata: 'FUK', icao: 'RJFF', name: 'Fukuoka',        lat: 33.586, lng: 130.451 },
        { iata: 'CTS', icao: 'RJCC', name: 'New Chitose',    lat: 42.775, lng: 141.692 }
    ];
    // å¤šä»»å‹™é€²åº¦ç®¡ç†
    const progressTasks = new Map(); // id -> { id, label, percent, eta, indeterminate, priority, etaTimer }

    // å¾Œç«¯ä»»å‹™æ¨™ç±¤
    const SERVER_TASK_LABELS = {
        'identify': 'ç›¸ä¼¼åˆ†æ',
        'identify-all': 'å¤šæ¼”ç®—æ³•åˆ†æ',
        'forecast-consensus': 'å…±è­˜é æ¸¬',
        'predict-lstm': 'LSTM é æ¸¬',
        'optimize': 'åƒæ•¸å„ªåŒ–'
    };

    function ensureProgressVisible() {
        const c = document.getElementById('progressContainer');
        if (c) c.style.display = progressTasks.size ? 'block' : 'none';
    }

    function renderProgress() {
        const primary = document.getElementById('progressPrimary');
        const secondaryWrap = document.getElementById('progressSecondary');
        if (!primary || !secondaryWrap) return;
        // æ’åºï¼špriority å¤§åœ¨å‰ï¼ŒåŒ priority ç”¨åŠ å…¥é †åºï¼ˆMap è¿­ä»£é †åºï¼‰
        const items = Array.from(progressTasks.values()).sort((a, b) => (b.priority||0) - (a.priority||0));
        const main = items[0];
        const rest = items.slice(1);
        // ä¸»ä»»å‹™
        const pLabel = primary.querySelector('.pi-label');
        const pMeta = primary.querySelector('.pi-meta');
        const pFill = primary.querySelector('.pi-fill');
        if (main) {
            pLabel.textContent = main.label || 'è™•ç†ä¸­â€¦';
            pMeta.textContent = `${Math.round(main.percent||0)}% Â· ETA ${formatETA(main.eta)}`;
            pFill.style.width = `${Math.max(0, Math.min(100, Math.round(main.percent||0)))}%`;
            if (main.indeterminate) pFill.classList.add('indeterminate'); else pFill.classList.remove('indeterminate');
            primary.style.display = '';
        } else {
            primary.style.display = 'none';
        }
        // å…¶é¤˜ä»»å‹™ï¼ˆå°æ¢ï¼‰
        secondaryWrap.innerHTML = '';
        rest.forEach(task => {
            const div = document.createElement('div');
            div.className = 'progress-item secondary';
            div.innerHTML = `<div class="pi-header"><span class="pi-label">${task.label||'è™•ç†ä¸­â€¦'}</span><span class="pi-meta">${Math.round(task.percent||0)}% Â· ETA ${formatETA(task.eta)}</span></div>
                             <div class="pi-bar"><div class="pi-fill${task.indeterminate?' indeterminate':''}" style="width:${Math.max(0, Math.min(100, Math.round(task.percent||0)))}%"></div></div>`;
            secondaryWrap.appendChild(div);
        });
        ensureProgressVisible();
    }

    function addProgressTask(id, label, options={}) {
        const task = {
            id,
            label: label || 'è™•ç†ä¸­â€¦',
            percent: 0,
            eta: null,
            indeterminate: !!options.indeterminate,
            priority: options.priority || 0,
            etaTimer: null
        };
        progressTasks.set(id, task);
        renderProgress();
        return task;
    }

    function updateProgressTask(id, updates={}) {
        const t = progressTasks.get(id);
        if (!t) return;
        Object.assign(t, updates);
        renderProgress();
    }

    function removeProgressTask(id) {
        const t = progressTasks.get(id);
        if (t && t.etaTimer) { clearInterval(t.etaTimer); }
        progressTasks.delete(id);
        renderProgress();
    }

        function updateStatus(message) {
            const s = document.getElementById('status');
            if (s) s.textContent = message;
            console.log(message);
        }

        function initMap() {
            try {
                console.log('ğŸ—ºï¸ åˆå§‹åŒ– Google Maps...');
                
                map = new google.maps.Map(document.getElementById('map'), {
                    zoom: 8,
                    center: { lat: 24.0, lng: 121.0 },
                    mapTypeId: google.maps.MapTypeId.ROADMAP
                });

                // ç¹ªåœ–ç®¡ç†å™¨ï¼ˆéš±è—é è¨­æ§åˆ¶åˆ—ï¼Œæˆ‘å€‘è‡ªå»ºä¸‰éµæ§åˆ¶ï¼‰
                drawingManager = new google.maps.drawing.DrawingManager({
                    drawingMode: null,
                    drawingControl: false,
                    polylineOptions: {
                        strokeColor: '#ff0000',
                        strokeOpacity: 1.0,
                        strokeWeight: 3
                    }
                });
                
                drawingManager.setMap(map);

                // ç¹ªè£½å®Œæˆäº‹ä»¶
                google.maps.event.addListener(drawingManager, 'polylinecomplete', function(polyline) {
                    // ç§»é™¤ä¹‹å‰çš„ç¹ªè£½ç·š
                    if (drawnPolyline) { drawnPolyline.setMap(null); }
                    drawnPolyline = polyline;
                    drawnPath = [];
                    const path = polyline.getPath();
                    
                    for (let i = 0; i < path.getLength(); i++) {
                        const point = path.getAt(i);
                        drawnPath.push({
                            lat: point.lat(),
                            lng: point.lng()
                        });
                    }
                    
                    updateStatus('âœ… è»Œè·¡ç¹ªè£½å®Œæˆï¼Œå…± ' + drawnPath.length + ' å€‹é»');
                    // ä¸åœ¨ç¹ªè£½å¾Œè‡ªå‹•é æ¸¬ï¼›éœ€å…ˆåˆ†æå¾Œå†è§¸ç™¼é æ¸¬
                });

                // æ·»åŠ æ¸¬è©¦æ¨™è¨˜
                const testMarker = new google.maps.Marker({
                    position: { lat: 25.0330, lng: 121.5654 },
                    map: map,
                    title: 'å°åŒ—101 - ç³»çµ±æ¸¬è©¦',
                    icon: {
                        path: google.maps.SymbolPath.CIRCLE,
                        scale: 8,
                        fillColor: '#4caf50',
                        fillOpacity: 0.8,
                        strokeWeight: 2,
                        strokeColor: '#ffffff'
                    }
                });

                updateStatus('âœ… åœ°åœ–è¼‰å…¥æˆåŠŸï¼');
                // è¼‰å…¥æ©Ÿå ´ç´¢å¼•ï¼ˆè‹¥å¤–éƒ¨ä¸å¯ç”¨å‰‡å›é€€å…§å»ºï¼‰
                preloadAirports();
                // åˆå§‹åŒ– LSTM æ§åˆ¶å…ƒä»¶
                initLstmControls();
                // è‡ªè¨‚ï¼šé ‚éƒ¨ä¸‰éµï¼ˆç§»å‹•ã€ç¹ªè£½ã€æ¸…é™¤ï¼‰
                const controlDiv = document.createElement('div');
                controlDiv.style.display = 'flex';
                controlDiv.style.gap = '6px';
                controlDiv.style.background = 'rgba(0,0,0,0.6)';
                controlDiv.style.padding = '6px';
                controlDiv.style.borderRadius = '8px';
                controlDiv.style.backdropFilter = 'blur(6px)';
                const mkBtn = (label, onClick) => {
                    const b = document.createElement('button');
                    b.textContent = label;
                    b.style.border = 'none';
                    b.style.padding = '6px 10px';
                    b.style.borderRadius = '6px';
                    b.style.cursor = 'pointer';
                    b.style.background = '#42a5f5';
                    b.style.color = '#fff';
                    b.style.fontSize = '12px';
                    b.onmouseenter = () => b.style.background = '#1e88e5';
                    b.onmouseleave = () => b.style.background = '#42a5f5';
                    b.onclick = onClick; return b;
                };
                // ç§»å‹•ï¼šé—œé–‰ç¹ªè£½æ¨¡å¼
                const moveBtn = mkBtn('ğŸ–ï¸ ç§»å‹•', () => {
                    drawingManager.setDrawingMode(null);
                });
                // ç¹ªè£½ï¼šå•Ÿç”¨ polyline æ¨¡å¼
                const drawBtn = mkBtn('âœï¸ ç¹ªè£½', () => {
                    drawingManager.setDrawingMode(google.maps.drawing.OverlayType.POLYLINE);
                });
                // æ¸…é™¤ï¼šç§»é™¤ç›®å‰ç¹ªè£½ç·šèˆ‡ bbox
                const clearBtn = mkBtn('ğŸ§¹ æ¸…é™¤', () => { clearDrawnPath(); });
                controlDiv.appendChild(moveBtn);
                controlDiv.appendChild(drawBtn);
                controlDiv.appendChild(clearBtn);
                map.controls[google.maps.ControlPosition.TOP_CENTER].push(controlDiv);
                
                // è‡ªå‹•è¼‰å…¥æ•¸æ“š
                setTimeout(() => {
                    testBackend();
                }, 1000);
                
            } catch (error) {
                updateStatus('âŒ åœ°åœ–åˆå§‹åŒ–å¤±æ•—: ' + error.message);
                console.error('åœ°åœ–éŒ¯èª¤:', error);
            }
        }

        function testBackend() {
            updateStatus('ğŸ” æ¸¬è©¦å¾Œç«¯é€£ç·š...');
            startLocalETA(3, 'æª¢æŸ¥å¾Œç«¯');
            
            fetch('/api/statistics')
                .then(response => {
                    if (!response.ok) {
                        throw new Error(`HTTP ${response.status}`);
                    }
                    return response.json();
                })
                .then(data => {
                    updateStatus(`âœ… å¾Œç«¯æ­£å¸¸ï¼å…±è¼‰å…¥ ${data.total_records} æ¢è¨˜éŒ„ï¼Œ${data.unique_flights} å€‹èˆªç­`);
                })
                .catch(error => {
                    updateStatus(`âŒ å¾Œç«¯é€£ç·šå¤±æ•—: ${error.message}`);
                    console.error('å¾Œç«¯éŒ¯èª¤:', error);
                });
        }

        function loadFlightData() {
            updateStatus('ğŸ“‚ è¼‰å…¥èˆªç­æ•¸æ“š...');
            addProgressTask('load:data', 'ä¸‹è¼‰èˆªç­', { indeterminate: true, priority: 90 });
            // ä½¿ç”¨å¸¶è·¯å¾‘çš„APIç²å–å®Œæ•´æ•¸æ“š
            fetch('/api/flights-with-paths?limit=' + currentFlightCount)
                .then(response => {
                    if (!response.ok) {
                        throw new Error(`HTTP ${response.status}`);
                    }
                    return response.json();
                })
                .then(data => {
                    // è½‰æ›æ•¸æ“šæ ¼å¼ä»¥åŒ¹é… showAllFlights çš„æœŸæœ›
                    allFlightData = data.map(flight => ({
                        id: flight.id,
                        coordinates: flight.path, // path å·²ç¶“æ˜¯ [{lat, lng}, ...] æ ¼å¼
                        segment: flight.segment,
                        source: flight.source,
                        points: flight.points
                    }));
                    
                    flightData = allFlightData.slice(0, currentFlightCount);
                    
                    updateStatus(`âœ… å·²è¼‰å…¥ ${flightData.length} å€‹èˆªç­æ•¸æ“š (å«è·¯å¾‘)`);
                    console.log('èˆªç­æ•¸æ“šè¼‰å…¥å®Œæˆ:', flightData.length);
                })
                .catch(error => {
                    updateStatus(`âŒ æ•¸æ“šè¼‰å…¥å¤±æ•—: ${error.message}`);
                    console.error('è¼‰å…¥éŒ¯èª¤:', error);
                })
                .finally(() => { removeProgressTask('load:data'); hideProgress(); });
        }

        function showAllFlights() {
            if (flightData.length === 0) {
                updateStatus('âŒ è«‹å…ˆè¼‰å…¥æ•¸æ“š');
                return;
            }
            
            updateStatus(`ğŸ”„ é¡¯ç¤º ${flightData.length} æ¢èˆªç·š...`);
            startLocalETA(4, 'ç¹ªè£½èˆªç·š');
            hideAllFlights();
            
            let displayCount = 0;
            const maxDisplay = flightData.length; // é¡¯ç¤ºæ‰€æœ‰è¼‰å…¥çš„æ•¸æ“š
            
            flightData.slice(0, maxDisplay).forEach((flight, index) => {
                if (flight.coordinates && flight.coordinates.length >= 2) {
                    // æ­£è¦åŒ–ä¸¦å»é‡ï¼Œç¢ºä¿é€£çºŒé¡¯ç¤º
                    const path = normalizePathCoords(flight.coordinates);
                    
                    const colors = ['#ff4444', '#44ff44', '#4444ff', '#ffff44', '#ff44ff', '#44ffff'];
                    
                    const polyline = new google.maps.Polyline({
                        path: path,
                        geodesic: true,
                        strokeColor: colors[index % colors.length],
                        strokeOpacity: 0.8,
                        strokeWeight: 2
                    });
                    
                    polyline.setMap(map);
                    flightPaths.push(polyline);
                    displayCount++;
                }
            });
            
            updateStatus(`âœ… å·²é¡¯ç¤º ${displayCount} æ¢èˆªç·š`);
        }

        function hideAllFlights() {
            startLocalETA(1, 'æ¸…é™¤èˆªç·š');
            flightPaths.forEach(path => {
                path.setMap(null);
            });
            flightPaths = [];
            updateStatus('ğŸš« å·²éš±è—æ‰€æœ‰èˆªç·š');
        }

        function setFlightCount(count) {
            currentFlightCount = count;
            const slider = document.getElementById('flightCountSlider');
            if (slider) slider.value = count;
            updateSliderDisplay();
            updateStatus(`ğŸ”§ è¨­å®šé¡¯ç¤º ${formatNumber(count)} å€‹èˆªç­`);
        }

        function updateSliderDisplay() {
            const slider = document.getElementById('flightCountSlider');
            const count = slider ? slider.value : currentFlightCount;
            const disp = document.getElementById('flightCountDisplay');
            if (disp) disp.textContent = formatNumber(count);
            currentFlightCount = parseInt(count);
        }

        function formatNumber(num) {
            if (num >= 1000000) {
                return (num / 1000000).toFixed(1) + 'M';
            } else if (num >= 1000) {
                return (num / 1000).toFixed(0) + 'K';
            }
            return num.toString();
        }

        // æ¼”ç®—æ³•è¦–çª—åŠŸèƒ½
        function openAlgorithmModal() {
            const m = document.getElementById('algorithmModal');
            if (m) m.style.display = 'block';
            updateStatus('ğŸ¯ é–‹å•Ÿæ¼”ç®—æ³•é¸æ“‡è¦–çª—');
        }

        function closeAlgorithmModal() {
            const m = document.getElementById('algorithmModal');
            if (m) m.style.display = 'none';
            updateStatus('ğŸ”§ é—œé–‰æ¼”ç®—æ³•è¦–çª—');
        }

        function selectAlgorithm(algorithm) {
            // æ¸…é™¤æ‰€æœ‰é¸ä¸­ç‹€æ…‹
            document.querySelectorAll('.algorithm-item').forEach(item => {
                item.classList.remove('selected');
            });
            
            // é¸ä¸­ç•¶å‰æ¼”ç®—æ³•
            const algEl = document.getElementById('alg-' + algorithm);
            if (algEl) algEl.classList.add('selected');
            currentAlgorithm = algorithm;
            
            updateStatus(`âœ… é¸æ“‡æ¼”ç®—æ³•: ${getAlgorithmName(algorithm)}`);

            // è‹¥å·²ç¶“æœ‰ä¸€æ¬¡ã€Œå…¨éƒ¨æ¼”ç®—æ³•ã€çš„çµæœï¼Œåˆ‡æ›æ¼”ç®—æ³•æ™‚ç›´æ¥é¡¯ç¤ºè©²æ¼”ç®—æ³•çš„ Top 5
            if (multiAlgorithmResults && multiAlgorithmResults[algorithm]) {
                displaySimilarFlights(multiAlgorithmResults[algorithm]);
                updateTopFiveList(multiAlgorithmResults[algorithm], algorithm);
            }
        }

        // è‹¥å¯ç”¨ï¼Œç¬¬ä¸€æ¬¡åˆ†ææ™‚è‡ªå‹•åœ¨èƒŒæ™¯å•Ÿå‹•è²è‘‰æ–¯å„ªåŒ–ï¼ˆé¿å…æ‰‹å‹•æŒ‰éˆ•ï¼‰
        async function maybeKickOffOptimizer() {
            try {
                if (window.__optKickStarted) return;
                const stat = await fetch('/api/statistics').then(r => r.ok ? r.json() : null).catch(()=>null);
                const ok = stat && stat.enhancements && stat.enhancements.bayesian_optimizer;
                if (!ok) return;
                const last = Number(localStorage.getItem('lastOptTs') || 0);
                const threeDays = 3 * 24 * 60 * 60 * 1000;
                if ((Date.now() - last) < threeDays) return;
                window.__optKickStarted = true;
                // å°è¦æ¨¡å˜—è©¦å³å¯ï¼Œä¸é˜»å¡æ“ä½œ
                fetch('/api/optimize-parameters', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ n_calls: 25, eval_total: 120 })
                }).then(() => {
                    localStorage.setItem('lastOptTs', String(Date.now()));
                }).catch(()=>{});
            } catch(_) {}
        }

    function runPrediction() {
            if (drawnPath.length < 2) {
                alert('âš ï¸ è«‹å…ˆåœ¨åœ°åœ–ä¸Šç¹ªè£½ä¸€æ¢è»Œè·¡è·¯å¾‘ï¼');
                return;
            }
            // è‡ªå‹•å•Ÿå‹•ä¸€æ¬¡èƒŒæ™¯åƒæ•¸å„ªåŒ–ï¼ˆè‹¥è¿‘æœŸæœªåŸ·è¡Œï¼‰
            maybeKickOffOptimizer();
            
            const algorithmName = getAlgorithmName(currentAlgorithm);
            const useEnhanced = true; // æ°¸é å•Ÿç”¨å¢å¼·ç®—æ³•
            
            updateStatus(`ğŸ¯ ä½¿ç”¨ ${algorithmName} (å¢å¼·ç‰ˆ) åˆ†æè»Œè·¡...`);
            
            // æº–å‚™ç™¼é€åˆ°å¾Œç«¯çš„è·¯å¾‘æ•¸æ“šï¼ˆFast Mode æœƒé™æ¡æ¨£ï¼‰
            const raw = drawnPath.map(point => ({ lat: point.lat, lng: point.lng }));
            const pathData = document.getElementById('fastMode').checked ? downsamplePath(raw, 2) : raw;
            
            // ä¸å†æä¾›æ‰‹å‹•é–‹é—œï¼Œå…ˆé€²è¡Œç›¸ä¼¼åº¦åˆ†æï¼Œå®Œæˆå¾Œè‡ªå‹•è§¸ç™¼ LSTM
            
            // æ§‹å»ºAPI URLï¼ˆåŒ…å«å¢å¼·æ¨¡å¼åƒæ•¸ï¼‰
            let apiUrl = `/api/identify?algo=${currentAlgorithm.toUpperCase()}&calibrate_percent=true&percent_mode=absolute&floor_pct=1&top_pct=100&time_budget_s=35`;
            apiUrl += '&enhanced=true';
            if (document.getElementById('fastMode').checked) {
                // èˆ‡å¾Œç«¯å°é½Šï¼Œä½¿ç”¨ subseq=true åƒæ•¸å
                apiUrl += '&subseq=true&stride=3&approx=true&fast=true&directional=true';
            }
            // è‹¥å•Ÿç”¨çŸ©å½¢éæ¿¾å‰‡é™„åŠ  bbox åƒæ•¸
            if (bboxFilterEnabled) {
                const bb = computeDrawnPathBBox();
                if (bb) {
                    const { minLat, minLng, maxLat, maxLng } = bb;
                    // èˆ‡å¾Œç«¯ API å°é½Šåƒæ•¸åç¨±: north/south/east/west
                    apiUrl += `&north=${maxLat}&south=${minLat}&east=${maxLng}&west=${minLng}`
                        + `&bbox_strict=${bboxStrictEnabled}`
                        + `&min_span_ratio=${minSpanRatio}`;
                }
            }
            
            // èª¿ç”¨å¾Œç«¯APIé€²è¡ŒçœŸå¯¦åˆ†æ
            addProgressTask('server:progress', 'ä¼ºæœå™¨åˆ†æ', { priority: 100 });
            startProgressPolling();
            startLocalETA(10, 'åˆ†æè»Œè·¡');
            fetch(apiUrl, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify(pathData)
            })
            .then(response => {
                if (!response.ok) {
                    throw new Error(`å¾Œç«¯APIéŒ¯èª¤: ${response.status}`);
                }
                return response.json();
            })
            .then(results => {
                if (results && results.length > 0) {
                    updateStatus(`âœ… ${algorithmName} (å¢å¼·ç‰ˆ) æ‰¾åˆ° ${results.length} å€‹ç›¸ä¼¼èˆªç­`);
                    
                    // é¡¯ç¤ºç½®ä¿¡åº¦ä¿¡æ¯ï¼ˆå¦‚æœæœ‰ï¼‰
                    if (results[0].confidence !== undefined) {
                        const avgConfidence = results.reduce((sum, r) => sum + (r.confidence || 0), 0) / results.length;
                        console.log(`ğŸ“Š å¹³å‡ç½®ä¿¡åº¦: ${(avgConfidence * 100).toFixed(1)}%`);
                    }
                    
                    // é¡¯ç¤ºç›¸ä¼¼èˆªç­çµæœ
                    displaySimilarFlights(results);
                    updateTopFiveList(results, currentAlgorithm);
                    // ç›®çš„åœ°æ¨ä¼° / åˆ†æåŸå› 
                    updateDestinationEstimates(results);
                    
                    // å„²å­˜çœŸå¯¦çµæœ
                    predictionResults[currentAlgorithm] = {
                        results: results,
                        algorithm: currentAlgorithm,
                        timestamp: Date.now()
                    };

                    // æ¸…é™¤ä¹‹å‰çš„ã€Œå…¨éƒ¨æ¼”ç®—æ³•ã€å¿«å–ä»¥é¿å…æ··æ·†
                    multiAlgorithmResults = null;
                    
                    // æ›´æ–°æ¼”ç®—æ³•æº–ç¢ºç‡é¡¯ç¤º
                    const accuracy = calculateRealAccuracy(results);
                    const accEl = document.querySelector(`#alg-${currentAlgorithm} .algorithm-accuracy`);
                    if (accEl) accEl.textContent = `æ‰¾åˆ° ${results.length} å€‹ç›¸ä¼¼èˆªç­`;
                    // åˆ†æå®Œæˆå¾Œåƒ…åŸ·è¡Œå…±è­˜é æ¸¬ï¼ˆåŒ…å«çµ‚é»ä¿è­·ï¼‰ï¼›æŠŠ Top IDs å‚³çµ¦å…±è­˜é æ¸¬é¿å…äºŒæ¬¡æƒå…¨åº«
                    try { autoPredictAfterAnalysis(results); } catch(_) {}
                        
                } else {
                    updateStatus(`âŒ ${algorithmName} æ²’æœ‰æ‰¾åˆ°ç›¸ä¼¼èˆªç­`);
                }
            })
            .catch(error => {
                updateStatus(`âŒ ${algorithmName} åˆ†æå¤±æ•—: ${error.message}`);
                console.error('é æ¸¬éŒ¯èª¤:', error);
            })
            .finally(() => {
                // äº¤çµ¦å¤šä»»å‹™è¼ªè©¢è‡ªå‹•ç®¡ç†ï¼›æœ¬åœ°åªç§»é™¤è‡¨æ™‚ä»»å‹™
                hideProgress();
            });
        }

        // ä¸€æ¬¡é‹è¡Œæ‰€æœ‰æ¼”ç®—æ³•ï¼Œä¸¦é¡¯ç¤ºæ¯å€‹æ¼”ç®—æ³•çš„ Top 5
        async function runAllAlgorithms() {
            if (drawnPath.length < 2) {
                alert('âš ï¸ è«‹å…ˆåœ¨åœ°åœ–ä¸Šç¹ªè£½ä¸€æ¢è»Œè·¡è·¯å¾‘ï¼');
                return;
            }
            const useEnhanced = true; // æ°¸é å•Ÿç”¨å¢å¼·ç®—æ³•
            const raw = drawnPath.map(p => ({ lat: p.lat, lng: p.lng }));
            const pathData = document.getElementById('fastMode').checked ? downsamplePath(raw, 2) : raw;
            updateStatus('âš¡ ä¸€æ¬¡é‹è¡Œæ‰€æœ‰æ¼”ç®—æ³•ä¸­â€¦');
            addProgressTask('server:progress', 'ä¸ƒç¨®æ¼”ç®—æ³•åˆ†æ', { priority: 100 });
            startProgressPolling();
            startLocalETA(15, 'ä¸ƒç¨®æ¼”ç®—æ³•åˆ†æ');
            try {
                let url = '/api/identify-all?enhanced=true&calibrate_percent=true&percent_mode=absolute&floor_pct=1&top_pct=100';
                if (document.getElementById('fastMode').checked) {
                    // èˆ‡å¾Œç«¯å°é½Šï¼Œä½¿ç”¨ subseq=true åƒæ•¸å
                    url += (url.includes('?') ? '&' : '?') + 'subseq=true&stride=3&approx=true&fast=true&directional=true';
                }
                if (bboxFilterEnabled) {
                    const bb = computeDrawnPathBBox();
                    if (bb) {
                        const { minLat, minLng, maxLat, maxLng } = bb;
                        // èˆ‡å¾Œç«¯ API å°é½Šåƒæ•¸åç¨±: north/south/east/west
                        url += (url.includes('?') ? '&' : '?')
                            + `north=${maxLat}&south=${minLat}&east=${maxLng}&west=${minLng}`
                            + `&bbox_strict=${bboxStrictEnabled}`
                            + `&min_span_ratio=${minSpanRatio}`;
                    }
                }
                const r = await fetch(url, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(pathData)
                });
                if (!r.ok) throw new Error(`HTTP ${r.status}`);
                const data = await r.json();
                // å¾Œç«¯æ ¼å¼: { results: { DTW: [...], ...}, algorithms: [...], total_flights: N }
                const resultMap = (data && data.results) ? data.results : data;
                // æ­£è¦åŒ–éµç‚ºå°å¯«ï¼Œé¿å…å¤§å°å¯«ä¸ä¸€è‡´
                const normalized = {};
                Object.keys(resultMap || {}).forEach(k => { normalized[(k || '').toLowerCase()] = resultMap[k]; });
                multiAlgorithmResults = normalized; // å½¢å¦‚ { dtw: [...], lcss: [...], ... }
                // ä¹ŸåŒæ­¥å­˜å…¥ comparison å„²å­˜ï¼Œä»¥ä¾¿ã€Œæ¯”è¼ƒã€æŒ‰éˆ•å¯ç”¨
                predictionResults = {};
                const now = Date.now();
                Object.keys(multiAlgorithmResults).forEach(k => {
                    const arr = multiAlgorithmResults[k] || [];
                    predictionResults[k] = { results: arr, algorithm: k, timestamp: now };
                });
                updateAlgorithmAccuracies();
                updateStatus('âœ… æ‰€æœ‰æ¼”ç®—æ³•å®Œæˆã€‚é»é¸æ¼”ç®—æ³•å¡ç‰‡å¯åˆ‡æ›æŸ¥çœ‹ Top 5 çµæœ');
                // é¡¯ç¤ºç•¶å‰é¸ä¸­æ¼”ç®—æ³•çµæœ
                if (multiAlgorithmResults[currentAlgorithm] && multiAlgorithmResults[currentAlgorithm].length) {
                    const res = multiAlgorithmResults[currentAlgorithm];
                    displaySimilarFlights(res);
                    updateTopFiveList(res, currentAlgorithm);
                    updateDestinationEstimates(res);
                    // åˆ†æå®Œæˆå¾Œè‡ªå‹•é æ¸¬ï¼ˆåŒ…å«çµ‚é»ä¿è­·ï¼‰
                    autoPredictAfterAnalysis(res);
                }
            } catch (e) {
                updateStatus(`âŒ å…¨æ¼”ç®—æ³•é‹è¡Œå¤±æ•—: ${e.message}`);
                console.error(e);
            } finally {
                hideProgress();
            }
        }

        // è¨ˆç®—ä½¿ç”¨è€…ç¹ªç·šçš„çŸ©å½¢é‚Šç•Œ
        function computeDrawnPathBBox() {
            if (!drawnPath || drawnPath.length === 0) return null;
            let minLat =  90, maxLat = -90, minLng =  180, maxLng = -180;
            drawnPath.forEach(p => {
                if (p.lat < minLat) minLat = p.lat;
                if (p.lat > maxLat) maxLat = p.lat;
                if (p.lng < minLng) minLng = p.lng;
                if (p.lng > maxLng) maxLng = p.lng;
            });
            // åŠ å…¥å°‘é‡é‚Šç•Œ paddingï¼ˆ5% æˆ–æœ€å°‘ 0.05 åº¦ï¼‰é¿å…æŠŠåˆç†å€™é¸åˆ‡æ‰
            const spanLat = Math.max(1e-6, maxLat - minLat);
            const spanLng = Math.max(1e-6, maxLng - minLng);
            const padLat = Math.max(0.05, spanLat * 0.05);
            const padLng = Math.max(0.05, spanLng * 0.05);
            minLat = Math.max(-90, minLat - padLat);
            maxLat = Math.min(90,  maxLat + padLat);
            minLng = Math.max(-180, minLng - padLng);
            maxLng = Math.min(180,  maxLng + padLng);
            return { minLat: +minLat.toFixed(6), minLng: +minLng.toFixed(6), maxLat: +maxLat.toFixed(6), maxLng: +maxLng.toFixed(6) };
        }

        // é–‹é—œçŸ©å½¢éæ¿¾ï¼Œä¸¦åœ¨åœ°åœ–ä¸Šç•«å‡ºçŸ©å½¢
        function toggleBBoxFilter() {
            bboxFilterEnabled = !bboxFilterEnabled;
            const bb = computeDrawnPathBBox();
            if (!bb) { alert('è«‹å…ˆç•«ä¸€æ¢è·¯å¾‘'); bboxFilterEnabled = false; return; }
            // æ¸…é™¤èˆŠçš„è¦†è“‹
            if (bboxOverlay) { bboxOverlay.setMap(null); bboxOverlay = null; }
            if (bboxFilterEnabled) {
                const sw = new google.maps.LatLng(bb.minLat, bb.minLng);
                const ne = new google.maps.LatLng(bb.maxLat, bb.maxLng);
                bboxOverlay = new google.maps.Rectangle({
                    strokeColor: '#00897b', strokeOpacity: 0.9, strokeWeight: 2,
                    fillColor: '#00897b', fillOpacity: 0.08,
                    map: map, bounds: new google.maps.LatLngBounds(sw, ne)
                });
                updateStatus(`ğŸ§± å·²å•Ÿç”¨çŸ©å½¢éæ¿¾ï¼š(${bb.minLat}, ${bb.minLng}) ~ (${bb.maxLat}, ${bb.maxLng})`);
            } else {
                updateStatus('ğŸ§± å·²é—œé–‰çŸ©å½¢éæ¿¾');
            }
        }

        function updateAlgorithmAccuracies() {
            if (!multiAlgorithmResults) return;
            const allKeys = Object.keys(multiAlgorithmResults);
            allKeys.forEach(k => {
                const el = document.querySelector('#alg-' + (k || '').toLowerCase() + ' .algorithm-accuracy');
                if (!el) return;
                const arr = multiAlgorithmResults[k] || [];
                if (!arr.length) { el.textContent = 'æ²’æœ‰çµæœ'; return; }
                const top = arr.slice(0,5);
                const scores = top.map(x => (Number(x.score)||0));
                const w = weightsFromScores(scores);
                const sf = softmax(w, 0.8);
                const bestPct = Math.max(...sf) * 100;
                el.textContent = `Top5 å°±ç·’ | æœ€ä½³ç›¸ä¼¼åº¦ ${(bestPct).toFixed(1)}%`;
            });
        }

        // å¾ Top-N çµæœæ¨ä¼°ç›®çš„åœ°ï¼šä»¥ 1/(score+eps) ç‚ºæ¬Šé‡å° Top-5 çµ‚é»é€²è¡ŒåŠ æ¬Šï¼Œä¸¦è¼¸å‡ºèªªæ˜
    async function updateDestinationEstimates(results) {
            try {
                const destSummary = document.getElementById('destSummary');
                const destDetails = document.getElementById('destDetails');
                if (!destSummary || !destDetails) return;
                destDetails.innerHTML = '';
                if (!Array.isArray(results) || results.length === 0) {
            weightedDestCenter = null;
            destSummary.textContent = 'å°šæœªåˆ†æ';
                    return;
                }
                const top = results.slice(0, 5);
                // å–å¾—æ¯å€‹å€™é¸èˆªç­çš„çµ‚é»
                const endPoints = [];
                for (let i = 0; i < top.length; i++) {
                    const r = top[i];
                    try {
                        const flight = await fetch(`/api/flight/${encodeURIComponent(r.flight)}`).then(x => x.json());
                        if (flight && Array.isArray(flight.coordinates) && flight.coordinates.length) {
                            const end = flight.coordinates[flight.coordinates.length - 1];
                            const weight = 1.0 / ((Number(r.score) || 0.0001) + 1e-6);
                            endPoints.push({ id: r.flight, end, weight, score: r.score });
                        }
                    } catch (_) {}
                }
                if (!endPoints.length) { weightedDestCenter = null; destSummary.textContent = 'ç„¡æ³•æ¨ä¼°ç›®çš„åœ°ï¼ˆç„¡æœ‰æ•ˆå€™é¸ï¼‰'; return; }
                // åŠ æ¬Šä¸­å¿ƒ
                const wSum = endPoints.reduce((s, e) => s + e.weight, 0);
                const center = endPoints.reduce((acc, e) => ({ lat: acc.lat + e.end.lat * e.weight, lng: acc.lng + e.end.lng * e.weight }), { lat: 0, lng: 0 });
                center.lat /= wSum; center.lng /= wSum;
                weightedDestCenter = center;
                // ç°¡å–®ä¸€è‡´æ€§ï¼šå¹³å‡çµ‚é»é–“è·ï¼ˆkmï¼‰
                let spread = 0, pairs = 0;
                for (let i = 0; i < endPoints.length; i++) {
                    for (let j = i + 1; j < endPoints.length; j++) {
                        spread += haversineKm(endPoints[i].end, endPoints[j].end); pairs++;
                    }
                }
                const avgSpread = pairs ? spread / pairs : 0;
                // èªªæ˜èˆ‡åˆ—è¡¨ï¼ˆç”¨ç™¾åˆ†æ¯”æ¬Šé‡ï¼Œä¸é¡¯ç¤ºåŸå§‹åˆ†æ•¸ï¼‰
                const eps = 1e-6;
                const wArr = endPoints.map(e => 1/((Number(e.score)||0)+eps));
                const wSum2 = wArr.reduce((a,b)=>a+b,0) || 1;
                const lines = endPoints.map((e, idx) => {
                    const pct = (wArr[idx]/wSum2*100).toFixed(1);
                    return `#${idx+1} ${e.id} Â· è²¢ç» ${pct}% Â· çµ‚é» (${e.end.lat.toFixed(3)}, ${e.end.lng.toFixed(3)})`;
                });
                // æ›´æ–°æ‘˜è¦ï¼ˆä¸è¦åœ¨é€™è£¡ç•«åœ°åœ–æ¨™è¨˜ï¼‰
                destSummary.textContent = predictedLastPoint
                    ? `é æ¸¬çµ‚é»ï¼š(${predictedLastPoint.lat.toFixed(3)}, ${predictedLastPoint.lng.toFixed(3)}) Â· å€™é¸åŠ æ¬Šä¸­å¿ƒï¼š(${center.lat.toFixed(3)}, ${center.lng.toFixed(3)}) Â· å·®è· â‰ˆ ${haversineKm(predictedLastPoint, center).toFixed(1)} km Â· ä¸€è‡´æ€§ â‰ˆ ${avgSpread.toFixed(1)} km`
                    : `å€™é¸åŠ æ¬Šä¸­å¿ƒï¼š(${center.lat.toFixed(3)}, ${center.lng.toFixed(3)}) Â· ä¸€è‡´æ€§(è¶Šå°è¶Šä¸€è‡´) â‰ˆ ${avgSpread.toFixed(1)} km`;
                lines.forEach(t => {
                    const li = document.createElement('li');
                    li.style.fontSize = '12px';
                    li.style.opacity = '0.9';
                    li.textContent = t;
                    destDetails.appendChild(li);
                });
            } catch (e) {
                console.error('æ›´æ–°ç›®çš„åœ°æ¨ä¼°æ™‚ç™¼ç”ŸéŒ¯èª¤', e);
            }
        }

        function refreshDestinationSummary() {
            try {
                const destSummary = document.getElementById('destSummary');
                if (!destSummary) return;
                if (!predictedLastPoint && !weightedDestCenter) { destSummary.textContent = 'å°šæœªåˆ†æ'; return; }
                const predLabel = predictedNearestAirport
                    ? (() => {
                        let pct = '';
                        if (predictedAirportScores && predictedAirportScores.length && predictedAirportScores[0].ap === predictedNearestAirport) {
                            pct = ` ${(predictedAirportScores[0].prob*100).toFixed(1)}%`;
                        }
                        return `é æ¸¬çµ‚é»ï¼š${predictedNearestAirport.iata||predictedNearestAirport.icao||''} ${predictedNearestAirport.name||''}${pct}`;
                    })()
                    : `é æ¸¬çµ‚é»ï¼š(${predictedLastPoint ? predictedLastPoint.lat.toFixed(3)+', '+predictedLastPoint.lng.toFixed(3) : '--'})`;
                if (predictedLastPoint && weightedDestCenter) {
                    destSummary.textContent = `${predLabel} Â· å€™é¸åŠ æ¬Šä¸­å¿ƒï¼š(${weightedDestCenter.lat.toFixed(3)}, ${weightedDestCenter.lng.toFixed(3)}) Â· å·®è· â‰ˆ ${haversineKm(predictedLastPoint, weightedDestCenter).toFixed(1)} km`;
                } else if (predictedLastPoint) {
                    destSummary.textContent = predLabel;
                } else if (weightedDestCenter) {
                    destSummary.textContent = `å€™é¸åŠ æ¬Šä¸­å¿ƒï¼š(${weightedDestCenter.lat.toFixed(3)}, ${weightedDestCenter.lng.toFixed(3)})`;
                }
            } catch (_) {}
        }

        // æ¸…é™¤ç›®å‰ç¹ªè£½çš„è·¯å¾‘èˆ‡çŸ©å½¢éæ¿¾
        function clearDrawnPath() {
            try {
                if (drawnPolyline) { drawnPolyline.setMap(null); drawnPolyline = null; }
                drawnPath = [];
                // é—œé–‰ä¸¦ç§»é™¤ç•¶å‰ bbox è¦†è“‹
                if (bboxOverlay) { bboxOverlay.setMap(null); bboxOverlay = null; }
                bboxFilterEnabled = false;
                updateStatus('ğŸ§¹ å·²æ¸…é™¤ç¹ªè£½è·¯å¾‘èˆ‡çŸ©å½¢éæ¿¾');
            } catch (e) {
                console.error('æ¸…é™¤ç¹ªè£½è·¯å¾‘å¤±æ•—', e);
            }
        }

        // é€²åº¦æ¢ç›¸é—œ
    // å…¼å®¹èˆŠä»‹é¢ï¼šshowProgress åªç¢ºä¿å®¹å™¨å¯è¦‹ï¼ˆå¤šä»»å‹™ç”± addProgressTask æ§åˆ¶ï¼‰
    function showProgress() { ensureProgressVisible(); }

        function hideProgress() {
                // åƒ…éš±è—å®¹å™¨ï¼›å¯¦éš›é—œé–‰ç”±å„ä»»å‹™ removeProgressTask è™•ç†
                // ä¿æŒè¼ªè©¢ï¼Œä»¥ä¾¿åŒæ™‚é¡¯ç¤ºå¤šå€‹ä»»å‹™ï¼›ç•¶ç„¡ä»»å‹™æ™‚å®¹å™¨è‡ªå‹•éš±è—
            if (localEtaTimer) { clearInterval(localEtaTimer); localEtaTimer = null; }
            ensureProgressVisible();
        }

        // æœ¬åœ° ETAï¼ˆç”Ÿæˆä¸€å€‹æ¬¡è¦ä»»å‹™ï¼Œä¸ä½”ç”¨ä¸»è¦æ¢ï¼›å¯æŒ‡å®š priority æ±ºå®šæ˜¯å¦ç½®é ‚ï¼‰
        function startLocalETA(seconds = 5, label = 'è™•ç†ä¸­', priority = 0) {
            try {
                const id = `local:${label}:${Date.now()}`;
                const task = addProgressTask(id, label, { indeterminate: true, priority });
                let remain = Math.max(1, Math.round(seconds));
                task.eta = remain; task.indeterminate = true; task.percent = 0;
                renderProgress();
                if (task.etaTimer) clearInterval(task.etaTimer);
                task.etaTimer = setInterval(() => {
                    remain = Math.max(0, remain - 1);
                    updateProgressTask(id, { eta: remain });
                    if (remain <= 0) { clearInterval(task.etaTimer); task.etaTimer = null; removeProgressTask(id); }
                }, 1000);
                return id;
            } catch (_) { return null; }
        }

        // èˆŠçš„å–®ä¸€é€²åº¦æ›´æ–°ï¼Œæ”¹ç‚ºæ›´æ–°ä¸€å€‹æ¨™æº–ä»»å‹™ï¼ˆid: 'server:progress'ï¼‰
        function updateProgress(percent, etaSeconds) {
            if (!progressTasks.has('server:progress')) addProgressTask('server:progress', 'ä¼ºæœå™¨åˆ†æ', { priority: 100 });
            updateProgressTask('server:progress', { percent: Math.max(0, Math.min(100, Math.round(percent || 0))), eta: etaSeconds, indeterminate: false });
            // å¦‚æœä¼ºæœå™¨é€²åº¦å›å ±ï¼Œç§»é™¤æœ¬åœ° ETA ä»»å‹™é¿å…é‡ç–Š
            for (const [id] of progressTasks.entries()) {
                if (String(id).startsWith('local:')) removeProgressTask(id);
            }
        }

        function formatETA(secs) {
            if (secs == null || isNaN(secs)) return '--';
            const s = Math.max(0, Math.round(secs));
            const m = Math.floor(s / 60);
            const ss = s % 60;
            return m > 0 ? `${m}m${ss}s` : `${ss}s`;
        }

        function startProgressPolling() {
            showProgress();
            if (progressInterval) { clearInterval(progressInterval); }
            progressInterval = setInterval(async () => {
                try {
                    const r = await fetch('/api/progress');
                    if (!r.ok) return; // å°šæœªé–‹å§‹æˆ–ä¸å¯ç”¨
                    const j = await r.json();
                    const tasks = Array.isArray(j.tasks) ? j.tasks : [];
                    if (tasks.length) {
                        // ä»¥å¾Œç«¯å¤šä»»å‹™ç‚ºæº–ï¼ŒåŒæ­¥æ¯å€‹ä»»å‹™ä¸€æ¢é€²åº¦
                        const present = new Set();
                        tasks.forEach(t => {
                            const tname = String(t.task || 'server');
                            const id = `server:${tname}`;
                            present.add(id);
                            const label = t.message || SERVER_TASK_LABELS[tname] || 'ä¼ºæœå™¨ä»»å‹™';
                            if (!progressTasks.has(id)) addProgressTask(id, label, { priority: (tname==='identify'||tname==='identify-all') ? 100 : 90 });
                            updateProgressTask(id, {
                                label,
                                percent: Math.max(0, Math.min(100, Number(t.percent)||0)),
                                eta: (t.eta_seconds != null) ? t.eta_seconds : null,
                                indeterminate: false
                            });
                            // å®Œæˆå³ç§»é™¤
                            if (t.done) removeProgressTask(id);
                        });
                        // ç§»é™¤ä¸å­˜åœ¨çš„ server ä»»å‹™èˆ‡å ä½ç¬¦
                        for (const [id] of progressTasks.entries()) {
                            if (id === 'server:progress') { removeProgressTask(id); continue; }
                            if (id.startsWith('server:') && !present.has(id)) removeProgressTask(id);
                        }
                    } else {
                        // å¾Œç«¯æœªæä¾›å¤šä»»å‹™ï¼šé€€å›å–®ä¸€å ä½ç¬¦
                        const pct = (j && (j.percent != null)) ? j.percent : (j && j.total ? (j.processed / j.total) * 100 : 0);
                        const eta = (j && (j.eta_seconds != null)) ? j.eta_seconds : (j ? j.eta : null);
                        updateProgress(pct, eta);
                    }
                } catch (e) {
                    // å¿½ç•¥è¼ªè©¢éŒ¯èª¤
                }
            }, 700);
        }

        // å·¥å…·ï¼šé™æ¡æ¨£è·¯å¾‘ä»¥åŠ é€Ÿ
        function downsamplePath(path, factor) {
            if (!Array.isArray(path) || path.length <= 2 || !factor || factor <= 1) return path;
            const out = [];
            for (let i = 0; i < path.length; i += factor) out.push(path[i]);
            if (out[out.length - 1] !== path[path.length - 1]) out.push(path[path.length - 1]);
            return out;
        }

        // æ›´æ–°å·¦å´ Top5 æ¸…å–®
        function updateTopFiveList(results, algorithm) {
            const list = document.getElementById('topFiveList');
            const empty = document.getElementById('topFiveEmpty');
            const label = document.getElementById('topFiveAlgoLabel');
            if (!list || !empty || !label) return;
            list.innerHTML = '';
            if (!results || !results.length) {
                empty.style.display = 'block';
                label.textContent = '(æ²’æœ‰çµæœ)';
                return;
            }
            empty.style.display = 'none';
            label.textContent = `(${getAlgorithmName(algorithm || currentAlgorithm)})`;
            // è¨ˆç®— Top-5 ç›¸å°ç›¸ä¼¼åº¦ï¼ˆç™¾åˆ†æ¯”ï¼‰ï¼Œé¿å…é¡¯ç¤ºé›£çœ‹çš„åŸå§‹åˆ†æ•¸ï¼›æ”¹ç”¨ softmax è®“å·®è·æ›´ç›´è¦º
            const topArr = results.slice(0, 5);
            const eps = 1e-6;
            const scores = topArr.map(x => (Number(x.score)||0));
            const weights = weightsFromScores(scores);
            const ws = weights.length ? weights : topArr.map(()=>1);
            const percents = softmax(ws, 0.8);
            topArr.forEach(async (r, idx) => {
                const li = document.createElement('li');
                li.style.padding = '8px';
                li.style.background = 'rgba(255,255,255,0.05)';
                li.style.borderRadius = '6px';
                li.style.cursor = 'pointer';
                li.title = `é»æ“Šä»¥èšç„¦èˆªç­ ${r.flight}`;
                // å…ˆé¡¯ç¤ºåŸºæœ¬è¡Œï¼Œç¨å¾Œè£œä¸Šå‰¯æ¨™é¡Œï¼ˆèˆªç­åç¨±/ä¾†æºï¼‰
                // å„ªå…ˆä½¿ç”¨å¾Œç«¯æä¾›çš„ similarity_percentï¼›å¦å‰‡é€€å› softmax
                const pctVal = (typeof r.similarity_percent === 'number' && isFinite(r.similarity_percent))
                    ? Math.max(0, Math.min(100, r.similarity_percent))
                    : Math.max(0, Math.min(100, (percents[idx] || 0) * 100));
                const pct = pctVal.toFixed(1);
                li.innerHTML = `<div style="display:flex; justify-content:space-between; align-items:center;">
                                        <div>
                                            <div><strong>#${idx + 1}</strong> èˆªç­ <span class="fn">ï¼ˆè¼‰å…¥ä¸­ï¼‰</span></div>
                                            <div class="sub" style="font-size:11px; opacity:.85; margin-top:2px;">è®€å–ä¸­â€¦</div>
                                        </div>
                                        <span style="opacity:.9; font-weight:600;">ç›¸ä¼¼åº¦ ${pct}%</span>
                                </div>`;
                li.onclick = () => focusFlight(r.flight, idx);
                list.appendChild(li);
                try {
                    const flight = await fetch(`/api/flight/${encodeURIComponent(r.flight)}`).then(x => x.json());
                    const sub = li.querySelector('.sub');
                                        const fn = li.querySelector('.fn');
                    if (sub) {
                        if (flight && (flight.name || flight.segment || flight.source)) {
                            const name = flight.name || '';
                            const seg = flight.segment ? `æ®µè½ ${flight.segment}` : '';
                            const src = flight.source ? `${flight.source}` : '';
                            const pieces = [name, seg, src].filter(Boolean);
                            sub.textContent = pieces.length ? pieces.join(' Â· ') : 'ï¼ˆç„¡å…¶ä»–è³‡è¨Šï¼‰';
                        } else {
                            sub.textContent = 'ï¼ˆç„¡å…¶ä»–è³‡è¨Šï¼‰';
                        }
                    }
                                        if (fn) fn.textContent = formatFlightName(r.flight, flight);
                } catch (_) {
                    const sub = li.querySelector('.sub');
                    if (sub) sub.textContent = 'ï¼ˆè¼‰å…¥åç¨±å¤±æ•—ï¼‰';
                }
            });
        }

        // èšç„¦èˆªç­ï¼šåƒ…èª¿æ•´ç·šæ¢ç²—ç´°ä»¥é«˜äº®ï¼Œä¸æ¸…é™¤å…¶ä»– Top5
        async function focusFlight(flightId, rankIndex) {
            try {
                // é‚„åŸå…ˆå‰é«˜äº®
                if (highlightedFlightId && topFivePolylineMap[highlightedFlightId]) {
                    topFivePolylineMap[highlightedFlightId].setOptions({ strokeWeight: 3, strokeOpacity: 0.85, zIndex: 0 });
                }
                // ç¢ºä¿ç›®æ¨™ polyline å­˜åœ¨ï¼Œè‹¥å°šæœªç¹ªè£½å‰‡è£œç¹ª
                let poly = topFivePolylineMap[flightId];
                if (!poly) {
                    const API_BASE = (window.location.origin && window.location.origin.startsWith('file:')) ? 'http://127.0.0.1:5000' : '';
                    const resp = await fetch(`${API_BASE}/api/flight/${encodeURIComponent(flightId)}`);
                    if (!resp.ok) throw new Error(`HTTP ${resp.status}`);
                    const flight = await resp.json();
                    if (!flight || !flight.coordinates || flight.coordinates.length < 2) return;
                    const norm = normalizePathCoords(flight.coordinates);
                    const color = ['#ff4444', '#44ff44', '#4444ff', '#ffff44', '#ff44ff'][rankIndex % 5] || '#ff8844';
                    poly = new google.maps.Polyline({
                        path: norm,
                        geodesic: true,
                        strokeColor: color,
                        strokeOpacity: 0.85,
                        strokeWeight: 3
                    });
                    poly.setMap(map);
                    topFivePolylineMap[flightId] = poly;
                    currentTopFiveIds.push(flightId);
                }
                // é«˜äº®é¡¯ç¤º
                poly.setOptions({ strokeWeight: 6, strokeOpacity: 1.0, zIndex: 1000 });
                highlightedFlightId = flightId;
                // è¦–é‡ç½®ä¸­æ–¼è©²èˆªç­
                const bounds = new google.maps.LatLngBounds();
                const gp = poly.getPath();
                for (let i = 0; i < gp.getLength(); i++) bounds.extend(gp.getAt(i));
                map.fitBounds(bounds);
            } catch (e) {
                console.error('èšç„¦èˆªç­å¤±æ•—', e);
            }
        }

        // é…ç½®ï¼šæ˜¯å¦è‡ªå‹•è§¸ç™¼ LSTM é æ¸¬ã€æ˜¯å¦é¡¯ç¤ºã€Œç™¼é€é æ¸¬è«‹æ±‚ä¸­ã€è¨Šæ¯
    const AUTO_PREDICT_ENABLED = true;    // åˆ†æå¾Œè‡ªå‹•é æ¸¬é–‹å•Ÿ
    const SHOW_PREDICT_STATUS = false;    // æƒ³é¡¯ç¤ºé€²åº¦æç¤ºæ™‚æ”¹ç‚º true
    const API_BASE = (window.location.origin && window.location.origin.startsWith('file:')) ? 'http://127.0.0.1:5000' : '';

        // LSTM æ·±åº¦å­¸ç¿’é æ¸¬ï¼ˆæ”¯æ´ { auto: boolean, horizon?: number } é¸é …ï¼‰
        function runLSTMPrediction(pathData, options = {}) {
            if (SHOW_PREDICT_STATUS) updateStatus('ğŸ§  ç™¼é€é æ¸¬è«‹æ±‚ä¸­â€¦');
            addProgressTask('predict:lstm', 'LSTM é æ¸¬', { indeterminate: true, priority: 95 });
            startLocalETA(10, 'LSTM é æ¸¬');
            // ä½¿ç”¨ auto horizon èˆ‡å¾Œç«¯çš„å‹•æ…‹ä¼°è¨ˆï¼Œä¸¦æŒ‡å®š model=lstm
            const q = new URLSearchParams({ model: 'lstm' });
            const auto = !!options.auto;
            if (auto) {
                q.set('horizon', 'auto');
                if (typeof options.min === 'number') q.set('min_steps', String(options.min));
                if (typeof options.max === 'number') q.set('max_steps', String(options.max));
                if (typeof options.base === 'number') q.set('base_steps', String(options.base));
            } else if (typeof options.horizon === 'number' && isFinite(options.horizon)) {
                q.set('horizon', String(Math.max(1, Math.round(options.horizon))));
            } else {
                q.set('horizon', 'auto');
            }
            fetch(API_BASE + '/api/predict-trajectory?' + q.toString(), {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(pathData)
            })
            .then(r => {
                if (!r.ok) throw new Error(`LSTM API éŒ¯èª¤: ${r.status}`);
                return r.json();
            })
            .then(res => {
                if (res.predicted_trajectory && res.predicted_trajectory.length) {
                    const algo = res.algorithm || 'Prediction';
                    if (SHOW_PREDICT_STATUS) updateStatus(`âœ… ${algo} å®Œæˆï¼Œé æ¸¬ ${res.prediction_horizon} å€‹æœªä¾†é»`);
                    displayPredictedTrajectory(res.predicted_trajectory);
                } else {
                    if (SHOW_PREDICT_STATUS) updateStatus('âŒ LSTM é æ¸¬æœªè¿”å›çµæœ');
                }
            })
            .catch(err => {
                if (SHOW_PREDICT_STATUS) updateStatus(`âŒ LSTM é æ¸¬å¤±æ•—: ${err.message}`);
                console.error(err);
            })
            .finally(() => { removeProgressTask('predict:lstm'); hideProgress(); });
        }

        // åˆå§‹åŒ– LSTM æ§åˆ¶ UI çš„äº‹ä»¶
        function initLstmControls() {
            try {
                const slider = document.getElementById('lstmHorizon');
                const disp = document.getElementById('lstmHorizonDisplay');
                const autoCk = document.getElementById('lstmAutoHorizon');
                const enableCk = document.getElementById('enableLSTM');
                if (slider && disp) {
                    const sync = () => { disp.textContent = String(slider.value); };
                    slider.addEventListener('input', sync);
                    slider.addEventListener('change', sync);
                    sync();
                }
                if (autoCk && slider) {
                    const toggle = () => { slider.disabled = !!autoCk.checked; slider.style.opacity = autoCk.checked ? 0.6 : 1; };
                    autoCk.addEventListener('change', toggle);
                    toggle();
                }
                if (enableCk) {
                    // é è¨­ä¸å•Ÿç”¨ï¼Œé¿å…èª¤è§¸
                    enableCk.checked = false;
                }
            } catch (_) {}
        }

        // ç”±æŒ‰éˆ•è§¸ç™¼çš„ LSTM åŸ·è¡Œ
        function runLSTMNow() {
            try {
                if (!drawnPath || drawnPath.length < 2) { alert('è«‹å…ˆåœ¨åœ°åœ–ä¸Šç¹ªè£½ä¸€æ¢è»Œè·¡'); return; }
                const enable = document.getElementById('enableLSTM');
                if (!enable || !enable.checked) { alert('è«‹å…ˆæ‰“é–‹ã€ŒLSTM æ‰‹å‹•ã€é–‹é—œ'); return; }
                const auto = !!(document.getElementById('lstmAutoHorizon')?.checked);
                const horizon = Number(document.getElementById('lstmHorizon')?.value || 80);
                const raw = drawnPath.map(p => ({ lat: p.lat, lng: p.lng }));
                const pathData = document.getElementById('fastMode').checked ? downsamplePath(raw, 2) : raw;
                const opts = auto ? { auto: true } : { auto: false, horizon: horizon };
                runLSTMPrediction(pathData, opts);
            } catch (e) {
                console.error('LSTM è§¸ç™¼å¤±æ•—', e);
            }
        }

        // è‡ªå‹•é æ¸¬ï¼ˆåˆ†æå¾Œè§¸ç™¼ï¼‰ï¼šæ›´ç©©å¥çš„åœ°å¹³ç·šä¼°è¨ˆï¼Œé¿å…éåº¦ç¸®çŸ­
    async function autoPredictAfterAnalysis(results) {
            if (!AUTO_PREDICT_ENABLED) return; // é—œé–‰è‡ªå‹•é æ¸¬
            try {
                if (!Array.isArray(results) || results.length === 0 || !drawnPath || drawnPath.length < 2) return;
                const lastPt = drawnPath[drawnPath.length - 1];
                // 1) é€Ÿåº¦è¶¨è¿‘ 0 æª¢æ¸¬ï¼šæœ€è¿‘å¹¾æ­¥çš„å¹³å‡æ­¥è·éå°å‰‡è¦–ç‚ºæŠµé”
                const recent = drawnPath.slice(Math.max(0, drawnPath.length - 5));
                const avgStepKm = averageStepDistance(recent);
                if (avgStepKm < 0.15) { // < 150m/æ­¥
                    updateStatus('ğŸ§­ å·²æ¥è¿‘çµ‚é»ï¼ˆé€Ÿåº¦æ¥µä½ï¼‰ï¼Œè·³éæœªä¾†è·¯å¾‘é æ¸¬');
                    return;
                }
                // 2) æœ€è¿‘æ©Ÿå ´è·é›¢ï¼ˆkmï¼‰ï¼Œç”¨æ–¼ã€Œè·é›¢â†’æ­¥æ•¸ã€çš„é€£çºŒæ˜ å°„
                let nearestDkm = null;
                // å„ªå…ˆå˜—è©¦å¾Œç«¯ OpenFlights æœ€è¿‘æ©Ÿå ´ APIï¼Œå¤±æ•—å†å›é€€åˆ°å‰ç«¯å…§å»ºåå–®
                try {
                    const q = new URLSearchParams({ lat: String(lastPt.lat||lastPt.latitude), lng: String(lastPt.lng||lastPt.longitude), k: '1', airport_only: 'true', require_iata: 'true' });
                    const resp = await fetch(API_BASE + '/api/openflights/nearest-airports?' + q.toString());
                    if (resp.ok) {
                        const data = await resp.json();
                        const arr = data && data.nearest ? data.nearest : [];
                        if (arr.length && typeof arr[0].distance_km === 'number' && isFinite(arr[0].distance_km)) {
                            nearestDkm = arr[0].distance_km;
                        }
                    }
                } catch (_) {}
                if (nearestDkm == null) {
                    try {
                        if (airportsIndex && airportsIndex.length) {
                            let best = Number.POSITIVE_INFINITY;
                            for (const ap of airportsIndex) {
                                const d = haversineKm(lastPt, ap);
                                if (d < best) best = d;
                            }
                            if (isFinite(best)) nearestDkm = best;
                        }
                    } catch (_) {}
                }
                // 3) å–å¾—å…±è­˜é æ¸¬ï¼šä½¿ç”¨é€£çºŒçš„ã€Œè·é›¢â†’æ­¥æ•¸ã€æ˜ å°„ï¼Œä¸å†æ¡ç”¨å€é–“å…§å›ºå®šæ­¥æ•¸
                const pathData = drawnPath.map(p => ({ lat: p.lat, lng: p.lng }));
                // UI é¡¯ç¤ºè·é›¢è³‡è¨Šï¼ˆé€£çºŒå€¼ï¼‰
                const nearMsg = (nearestDkm != null) ? `ã€è·æ©Ÿå ´â‰ˆ${nearestDkm.toFixed(0)}km` : '';
                // ä¼°è¨ˆæ¯æ­¥è·é›¢ï¼šç”¨æœ€è¿‘å¹¾æ­¥å¹³å‡ï¼Œè¨­ä¸‹é™é¿å…æ­¥è·éå°é€ æˆæ­¥æ•¸çˆ†ç‚¸
                const stepKm = Math.max(0.3, Math.min(50, isFinite(avgStepKm) ? avgStepKm : 1.0));
                updateStatus(`ğŸ§  å…±è­˜é æ¸¬ä¸­ï¼ˆè·é›¢â†’æ­¥æ•¸ï¼š${(nearestDkm!=null?nearestDkm.toFixed(0):'--')}km Ã· ${stepKm.toFixed(2)}km/æ­¥ï¼‰â€¦`);
                addProgressTask('predict:consensus', 'å…±è­˜é æ¸¬', { indeterminate: true, priority: 98 });
                // ä¹Ÿè¼ªè©¢ä¼ºæœå™¨é€²åº¦ï¼ˆè‹¥å¾Œç«¯æä¾› ETA / ç™¾åˆ†æ¯”ï¼Œæœƒè‡ªå‹•åŒæ­¥åˆ°ä¸»é€²åº¦æ¢ï¼‰
                startProgressPolling();
                startLocalETA(7, 'å…±è­˜é æ¸¬');
                let url = `/api/forecast-consensus?algo=${currentAlgorithm.toUpperCase()}`;
                if (document.getElementById('fastMode').checked) {
                    url += '&subseq=true&stride=3&fast=true&directional=true';
                }
                if (nearestDkm != null && isFinite(nearestDkm)) {
                    url += `&horizon=distance&step_km=${encodeURIComponent(stepKm)}&distance_km=${encodeURIComponent(nearestDkm)}&min_steps=1&max_steps=360`;
                } else {
                    // å¾Œæ´ï¼šè‹¥ç„¡æ³•ä¼°è·é›¢ï¼Œé€€å› autoï¼ˆä»å¯é€£çºŒè®ŠåŒ–ï¼Œç„¡å€é–“å›ºå®šå€¼ï¼‰
                    url += `&horizon=auto&min_steps=1&max_steps=360`;
                }
                // å‚³å…¥ identify çš„ Top IDsï¼Œè®“å¾Œç«¯åªåœ¨é€™äº›å€™é¸ä¸ŠåšçºŒèˆªèˆ‡åŠ æ¬Š
                const topIds = (Array.isArray(results)?results.slice(0,8):[]).map(r => r.flight);
                const res = await fetch(url, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ query_path: pathData, top_flights: topIds }) })
                    .then(r => { if (!r.ok) throw new Error(`HTTP ${r.status}`); return r.json(); });
                let traj = Array.isArray(res.consensus) ? res.consensus.slice() : [];
                if (!traj.length) { updateStatus('âš ï¸ å…±è­˜é æ¸¬æœªç”Ÿæˆè·¯å¾‘'); return; }
                // é˜²è­·ä¸Šé™ï¼Œé¿å…æ¥µç«¯é•·åº¦
                if (traj.length > 600) traj = traj.slice(0, 600);
                const hmode = res.horizon_mode ? (res.horizon_mode === 'distance' ? 'è·é›¢' : (res.horizon_mode === 'auto' ? 'å‹•æ…‹' : 'å›ºå®š')) : 'è·é›¢';
                updateStatus(`âœ… å…±è­˜é æ¸¬å®Œæˆï¼ˆ${hmode} Â· Top${res.topN_used||0} Â· æ­¥æ•¸ ${traj.length}ï¼‰`);
                displayPredictedTrajectory(traj);
            } catch (err) {
                updateStatus(`âŒ è‡ªå‹•é æ¸¬å¤±æ•—: ${err.message}`);
                console.error(err);
            } finally {
                removeProgressTask('predict:consensus');
                ensureProgressVisible();
            }
        }

        // é¡¯ç¤ºå‹å–„çš„èˆªç­åç¨±ï¼ˆç›¡é‡èƒå– BR357 / ANA123ï¼›å»£æ³›æƒæå­—ä¸²æ¬„ä½ï¼Œé¿å…æŠŠæ—¥æœŸç•¶æˆèˆªç­è™Ÿï¼‰
        function formatFlightName(flightId, flightObj) {
            const clean = (s) => (typeof s === 'string' ? s.trim() : '');
            const up = (s) => clean(s).toUpperCase();
            const id = up(flightId);
            const f = flightObj || {};

            // æ›´å¯¬é¬†çš„è§£æï¼šå…è¨±ç©ºæ ¼/é€£å­—è™Ÿ/åº•ç·šåˆ†éš”ï¼›é¿å… 8 ä½æ—¥æœŸï¼ˆ20xxxxxxï¼‰
            const tryExtractFromString = (str) => {
                const s = up(str);
                if (!s) return '';
                // å–æ‰€æœ‰å¯èƒ½åŒ¹é…ï¼Œé¸æ“‡ç¬¬ä¸€å€‹åˆç†è€…
                const re = /\b([A-Z]{2,3})[ _-]?(\d{2,5})([A-Z]?)\b/g;
                let m;
                while ((m = re.exec(s)) !== null) {
                    const letters = m[1];
                    let digits = m[2];
                    const suffix = m[3] || '';
                    // æ¿¾æ‰æ—¥æœŸæ¨£å¼ï¼Œä¾‹å¦‚ 20250807ã€202501ã€200101
                    if ((digits.length >= 6 && /^20\d{4,}$/.test(digits)) || /^\d{6,}$/.test(digits)) continue;
                    digits = String(parseInt(digits, 10)); // å»å‰å° 0
                    if (!digits || digits === 'NaN') continue;
                    return letters + digits + suffix;
                }
                return '';
            };

            // å¾å¸¸è¦‹æ¬„ä½å„ªå…ˆ
            const primaryKeys = ['callsign', 'flight_number', 'ident', 'name', 'iata', 'icao', 'number'];
            for (const k of primaryKeys) {
                if (k in f) {
                    const code = tryExtractFromString(f[k]);
                    if (code) return code;
                }
            }
            // è‹¥ç„¡ï¼Œæƒæç‰©ä»¶æ‰€æœ‰å­—ä¸²æ¬„ä½ï¼ˆå«æ·ºå±¤ç‰©ä»¶/é™£åˆ—ï¼‰
            const visited = new Set();
            const scan = (obj, depth=0) => {
                if (!obj || typeof obj !== 'object' || depth > 2 || visited.has(obj)) return '';
                visited.add(obj);
                if (Array.isArray(obj)) {
                    for (const v of obj) {
                        if (typeof v === 'string') { const c = tryExtractFromString(v); if (c) return c; }
                        if (typeof v === 'object') { const c = scan(v, depth+1); if (c) return c; }
                    }
                } else {
                    for (const key of Object.keys(obj)) {
                        const v = obj[key];
                        if (typeof v === 'string') { const c = tryExtractFromString(v); if (c) return c; }
                        if (typeof v === 'object') { const c = scan(v, depth+1); if (c) return c; }
                    }
                }
                return '';
            };
            const deepCode = scan(f, 0);
            if (deepCode) return deepCode;

            // å†å˜—è©¦å¾ id æœ¬èº«æ“·å–
            const idCode = tryExtractFromString(id);
            if (idCode) return idCode;

            // ä»ç„¡æ³•ï¼šæä¾›ä¸­æ€§å ä½ä¸¦é™„ä¸Š id æœ«ç¢¼ï¼Œä»¥ä¾¿å€åˆ†
            const suffix = (id.match(/([A-Z0-9]{4,})$/) || [,''])[1];
            return suffix ? `æœªçŸ¥èˆªç­ (${suffix})` : 'æœªçŸ¥èˆªç­';
        }

        // å·¥å…·ï¼šå¹³å‡æ­¥è·ï¼ˆkmï¼‰
        function averageStepDistance(points) {
            if (!Array.isArray(points) || points.length < 2) return Infinity;
            let sum = 0, cnt = 0;
            for (let i = 1; i < points.length; i++) {
                sum += haversineKm(points[i-1], points[i]);
                cnt++;
            }
            return cnt ? (sum / cnt) : Infinity;
        }

        // å·¥å…·ï¼šåˆ†ä½æ•¸ï¼ˆp âˆˆ (0,1]ï¼‰ï¼Œç°¡å–®å°±åœ°æ’åºæ³•
        function percentile(arr, p) {
            if (!Array.isArray(arr) || !arr.length) return 0;
            const a = arr.slice().sort((x, y) => x - y);
            const pp = Math.max(0, Math.min(1, Number(p) || 0));
            const idx = Math.min(a.length - 1, Math.round((a.length - 1) * pp));
            return a[idx];
        }

        // å·¥å…·ï¼šSoftmaxï¼ˆæŠŠç›¸å°æ¬Šé‡è½‰æˆæ›´ç›´è¦ºçš„ç™¾åˆ†æ¯”ï¼‰ï¼Œtau<1 æœƒæ”¾å¤§æœ€å¤§å€¼
        function softmax(arr, tau = 1.0) {
            if (!Array.isArray(arr) || !arr.length) return [];
            const t = Math.max(1e-6, Number(tau) || 1.0);
            const scaled = arr.map(x => (Number(x) || 0) / t);
            const m = Math.max(...scaled);
            const exps = scaled.map(v => Math.exp(v - m));
            const s = exps.reduce((a,b)=>a+b, 0) || 1;
            return exps.map(e => e / s);
        }

        function normalizeWeights(arr) {
            const a = Array.isArray(arr) ? arr.slice() : [];
            const s = a.reduce((x,y)=>x+(Number(y)||0), 0);
            if (!(s > 0)) return a.map(_=>1/Math.max(1,a.length));
            return a.map(v => (Number(v)||0)/s);
        }

        // è‹¥åˆ†å¸ƒéæ–¼å¹³å¦ï¼Œèˆ‡åæ¬¡æ¬Šé‡æ··åˆï¼Œé¿å…å…¨éƒ¨ 20%
        function emphasizePercents(percs) {
            if (!Array.isArray(percs) || percs.length === 0) return percs;
            const maxV = Math.max(...percs);
            const sorted = percs.slice().sort((a,b)=>a-b);
            const med = sorted[Math.floor(sorted.length/2)];
            if ((maxV - med) < 0.03) { // <3% å¹¾ä¹å¹³å¦
                const n = percs.length;
                const rankW = Array.from({length:n}, (_,i)=> (n - i)); // 5,4,3,2,1
                const rankP = normalizeWeights(rankW);
                const blended = percs.map((p,i)=> 0.6*p + 0.4*rankP[i]);
                return normalizeWeights(blended);
            }
            return percs;
        }

        // å·¥å…·ï¼šä¾åˆ†æ•¸ç”¢ç”Ÿæ¬Šé‡ï¼ˆè€ƒé‡åˆ†æ•¸è½å·®ï¼‰ã€‚
        // è‹¥åˆ†æ•¸å¹¾ä¹ç›¸åŒï¼Œå›é€€åˆ°æŒ‰åæ¬¡çš„æ¬Šé‡ï¼ˆé¿å…å…¨éƒ¨ 20%ï¼‰ã€‚
        function weightsFromScores(scores) {
            const arr = Array.isArray(scores) ? scores.map(x => Number(x)) : [];
            if (!arr.length) return [];
            let minS = Infinity, maxS = -Infinity;
            for (const s of arr) {
                if (!isFinite(s)) continue;
                if (s < minS) minS = s;
                if (s > maxS) maxS = s;
            }
            if (!isFinite(minS) || !isFinite(maxS)) {
                // è³‡æ–™ç•°å¸¸ï¼Œå¹³å‡åˆ†é…
                return arr.map(_ => 1);
            }
            const spread = maxS - minS;
            if (spread < 1e-6) {
                // å¹¾ä¹ç›¸åŒåˆ†æ•¸ï¼šç”¨åæ¬¡å€åˆ†ï¼ˆ5,4,3,2,1...ï¼‰
                return arr.map((_, i) => Math.max(1, (arr.length - i)));
            }
            const scale = Math.max(spread / 3, 1e-6);
            return arr.map(s => Math.exp(-(s - minS) / scale));
        }

        // å·¥å…·ï¼šHaversine è·é›¢ï¼ˆkmï¼‰
        function haversineKm(a, b) {
            const toRad = d => d * Math.PI / 180;
            const R = 6371;
            const aLat = a.lat ?? a.latitude, aLng = a.lng ?? a.longitude;
            const bLat = b.lat ?? b.latitude, bLng = b.lng ?? b.longitude;
            const dLat = toRad(bLat - aLat);
            const dLng = toRad(bLng - aLng);
            const lat1 = toRad(aLat);
            const lat2 = toRad(bLat);
            const h = Math.sin(dLat/2)**2 + Math.cos(lat1)*Math.cos(lat2)*Math.sin(dLng/2)**2;
            return 2 * R * Math.asin(Math.sqrt(h));
        }

        // å·¥å…·ï¼šæ–¹ä½è§’ã€ç›®çš„åœ°é»è¨ˆç®—
        function bearingDeg(a, b) {
            const toRad = d => d * Math.PI / 180;
            const toDeg = r => r * 180 / Math.PI;
            const lat1 = toRad(a.lat ?? a.latitude), lon1 = toRad(a.lng ?? a.longitude);
            const lat2 = toRad(b.lat ?? b.latitude), lon2 = toRad(b.lng ?? b.longitude);
            const dLon = lon2 - lon1;
            const y = Math.sin(dLon) * Math.cos(lat2);
            const x = Math.cos(lat1)*Math.cos(lat2) * Math.cos(dLon) - Math.sin(lat1)*Math.sin(lat2);
            let brng = toDeg(Math.atan2(y, x));
            if (!isFinite(brng)) return 0;
            return (brng + 360) % 360;
        }
        function destinationPoint(start, bearing, distanceKm) {
            const toRad = d => d * Math.PI / 180;
            const toDeg = r => r * 180 / Math.PI;
            const R = 6371;
            const Î´ = distanceKm / R;
            const Î¸ = toRad(bearing);
            const Ï†1 = toRad(start.lat ?? start.latitude);
            const Î»1 = toRad(start.lng ?? start.longitude);
            const sinÏ†1 = Math.sin(Ï†1), cosÏ†1 = Math.cos(Ï†1);
            const sinÎ´ = Math.sin(Î´), cosÎ´ = Math.cos(Î´);
            const sinÏ†2 = sinÏ†1 * cosÎ´ + cosÏ†1 * sinÎ´ * Math.cos(Î¸);
            const Ï†2 = Math.asin(sinÏ†2);
            const y = Math.sin(Î¸) * sinÎ´ * cosÏ†1;
            const x = cosÎ´ - sinÏ†1 * sinÏ†2;
            const Î»2 = Î»1 + Math.atan2(y, x);
            return { lat: toDeg(Ï†2), lng: ((toDeg(Î»2) + 540) % 360) - 180 };
        }
        function angleDiffDeg(a, b) {
            let d = ((a - b + 540) % 360) - 180;
            return Math.abs(d);
        }

        // é€Ÿåº¦å¤–æ¨ï¼šä½¿ç”¨æœ€è¿‘ N æ®µçš„å¹³å‡æ­¥è·èˆ‡å¹³å‡æ–¹ä½è§’ï¼Œç”Ÿæˆæœªä¾†æ­¥
        function computeVelocityExtrapolationPath(basePath, steps = 80) {
            try {
                const pts = Array.isArray(basePath) ? basePath : [];
                if (pts.length < 3) return [];
                const N = Math.min(6, pts.length - 1);
                let totalKm = 0, bearings = [];
                for (let i = pts.length - N - 1; i < pts.length - 1; i++) {
                    const a = pts[i], b = pts[i+1];
                    totalKm += haversineKm(a, b);
                    bearings.push(bearingDeg(a, b));
                }
                const avgStepKm = Math.max(0.5, totalKm / N); // æ¯æ­¥è‡³å°‘ 0.5kmï¼Œé¿å…éçŸ­
                // å‡å€¼æ–¹å‘ï¼ˆè€ƒæ…®ç’°å½¢å¹³å‡ï¼‰
                const toRad = d => d * Math.PI / 180;
                const toDeg = r => r * 180 / Math.PI;
                let sx = 0, sy = 0;
                bearings.forEach(d => { sx += Math.cos(toRad(d)); sy += Math.sin(toRad(d)); });
                const avgBearing = (toDeg(Math.atan2(sy, sx)) + 360) % 360;
                const out = [];
                let cur = pts[pts.length - 1];
                for (let k = 0; k < steps; k++) {
                    cur = destinationPoint(cur, avgBearing, avgStepKm);
                    out.push(cur);
                }
                return out;
            } catch (_) { return []; }
        }

        // å·¥å…·ï¼šæ‰¾å‡ºåº§æ¨™é™£åˆ—ä¸­è·é›¢ç›®æ¨™é»æœ€è¿‘çš„ç´¢å¼•
        function nearestIndex(coords, target) {
            let bestI = 0, bestD = Number.POSITIVE_INFINITY;
            for (let i = 0; i < coords.length; i++) {
                const d = haversineKm(coords[i], target);
                if (d < bestD) { bestD = d; bestI = i; }
            }
            return bestI;
        }

        // é¡¯ç¤ºé æ¸¬è»Œè·¡
    async function displayPredictedTrajectory(predictedPoints) {
            // å°‡é æ¸¬è·¯å¾‘é¦–é»é€£åˆ°ç”¨æˆ¶æœ€å¾Œç¹ªè£½çš„é»ï¼Œä½¿è¦–è¦ºä¸Šé€£çºŒ
            let pathToDraw = Array.isArray(predictedPoints) ? normalizePathCoords(predictedPoints) : [];
            if (drawnPath && drawnPath.length > 0 && pathToDraw.length > 0) {
                const last = drawnPath[drawnPath.length - 1];
                const first = pathToDraw[0];
                if (last && (last.lat !== first.lat || last.lng !== first.lng)) {
                    pathToDraw.unshift({ lat: last.lat, lng: last.lng });
                }
            }
            // åŸºæ–¼ Top-5 + é€Ÿåº¦å¤–æ¨ + æ©Ÿå ´é„°è¿‘æ€§ ä¾†è©•åˆ†å¯èƒ½ç›®çš„åœ°ï¼ˆä»¥ç™¾åˆ†æ¯”é¡¯ç¤ºï¼‰
            predictedNearestAirport = null;
            predictedAirportScores = null;
            try {
                if (airportsIndex && airportsIndex.length && drawnPath && drawnPath.length >= 3) {
                    const last = drawnPath[drawnPath.length - 1];
                    const velEx = computeVelocityExtrapolationPath(drawnPath, Math.max(50, Math.min(200, Math.round((pathToDraw.length||80)*1.0))));
                    const velEnd = velEx.length ? velEx[velEx.length - 1] : last;
                    // å€™é¸æ©Ÿå ´ï¼šè·é›¢æœ€å¾Œé» 600km ä»¥å…§
                    const cand = [];
                    for (const ap of airportsIndex) {
                        const dkm = haversineKm(last, ap);
                        if (dkm <= 600) cand.push({ ap, dLast: dkm });
                    }
                    // å¾å¾Œç«¯è£œé½Šã€Œé™„è¿‘æ©Ÿå ´ã€ä»¥é¿å…å‰ç«¯ç´¢å¼•ç¼ºæ¼ï¼ˆå– end æˆ– last å‘¨é‚Šï¼‰
                    try {
                        const endRef = (pathToDraw && pathToDraw.length) ? pathToDraw[pathToDraw.length-1] : last;
                        const q = new URLSearchParams({ lat: String(endRef.lat), lng: String(endRef.lng), k: '8', airport_only: 'true', require_iata: 'false' });
                        const resp = await fetch('/api/openflights/nearest-airports?' + q.toString());
                        if (resp.ok) {
                            const arr = await resp.json();
                            if (Array.isArray(arr)) {
                                for (const it of arr) {
                                    const exists = cand.some(c => ((c.ap.iata||'') && (c.ap.iata||'') === (it.iata||'')) || ((c.ap.icao||'') && (c.ap.icao||'') === (it.icao||'')));
                                    if (!exists && isFinite(it.lat) && isFinite(it.lng)) {
                                        cand.push({ ap: { iata: it.iata, icao: it.icao, name: it.name, lat: it.lat, lng: it.lng }, dLast: haversineKm(last, it) });
                                    }
                                }
                            }
                        }
                    } catch(_){ /* å¿½ç•¥å¾Œç«¯ä¸å¯ç”¨çš„æƒ…æ³ */ }
                    // å¦‚æœåœ¨æ±äº¬é™„è¿‘ï¼Œç¢ºä¿ NRT/HND åœ¨å€™é¸
                    const ensureIata = (code) => {
                        const idx = airportsIndex.findIndex(a => (a.iata||'').toUpperCase() === code);
                        if (idx >= 0 && !cand.some(c => (c.ap.iata||'') === code)) {
                            cand.push({ ap: airportsIndex[idx], dLast: haversineKm(last, airportsIndex[idx]) });
                        }
                    };
                    ensureIata('NRT'); ensureIata('HND');
                    // æ–¹å‘ä¸€è‡´æ€§ï¼šä½¿ç”¨æœ€è¿‘æ®µå¹³å‡æ–¹ä½èˆ‡æ©Ÿå ´æ–¹ä½å¤¾è§’
                    const recentN = Math.min(6, drawnPath.length - 1);
                    let sx=0, sy=0, stepSum=0;
                    for (let i = drawnPath.length - recentN - 1; i < drawnPath.length - 1; i++) {
                        const a = drawnPath[i], b = drawnPath[i+1];
                        stepSum += haversineKm(a, b);
                        const bd = bearingDeg(a, b);
                        sx += Math.cos(bd*Math.PI/180); sy += Math.sin(bd*Math.PI/180);
                    }
                    const avgBr = (Math.atan2(sy, sx) * 180/Math.PI + 360)%360;
                    // ä¾†è‡ª Top-5 çš„åŠ æ¬Šç›®çš„åœ°ä¸­å¿ƒï¼ˆè‹¥æœ‰ï¼‰
                    const center = weightedDestCenter;
                    // è‹¥å·²éå¸¸æ¥è¿‘æŸæ©Ÿå ´ï¼ˆä»¥æœ€å¾Œé»ç‚ºæº–ï¼‰ï¼Œç›´æ¥å„ªå…ˆè€ƒæ…®å¸é™„
                    let closest = null; let minD = Number.POSITIVE_INFINITY;
                    for (const c of cand) { if (c.dLast < minD) { minD = c.dLast; closest = c; } }
                    // è¿‘è·é›¢é–¾å€¼ä¾å¹³å‡æ­¥è·èª¿æ•´ï¼ˆ2~12kmï¼‰
                    const avgStepKm = stepSum / Math.max(1, recentN);
                    const nearKm = Math.max(2, Math.min(12, (avgStepKm||3)*2));
                    // è©•åˆ†ï¼šè·é›¢ã€æ–¹å‘ã€é€Ÿåº¦å¤–æ¨å°æº–ã€èˆ‡ä¸­å¿ƒä¸€è‡´æ€§
                    const items = cand.map(c => {
                        const ap = c.ap;
                        const dPred = (pathToDraw.length ? haversineKm(pathToDraw[pathToDraw.length-1], ap) : c.dLast);
                        const dVel = haversineKm(velEnd, ap);
                        const brToAp = bearingDeg(last, ap);
                        const ang = angleDiffDeg(avgBr, brToAp);
                        const centerBonus = center ? Math.max(0, 1 - Math.min(1, haversineKm(center, ap)/400)) : 0; // 400km å…§åŠ åˆ†
                        const sNear = 1 / (1 + Math.max(0, c.dLast)/20); // è·é›¢æœ€å¾Œé»çš„è²¼è¿‘åˆ†
                        // è½‰æˆ 0~1 åˆ†æ•¸ï¼šè·é›¢åæ¯”ã€è§’åº¦éš¨ç›¸å·®éæ¸›
                        const sDist = 1 / (1 + Math.max(0, dPred)/150);
                        const sVel = 1 / (1 + Math.max(0, dVel)/200);
                        const sAngle = Math.max(0, 1 - (ang/90)); // 0åº¦=1, 90åº¦=0, 180åº¦=è² â†’æˆªæ–·ç‚º0
                        const s = 0.40*sDist + 0.25*sAngle + 0.20*sVel + 0.10*sNear + 0.05*centerBonus;
                        return { ap, s, dLast: c.dLast };
                    });
                    // æ­£è¦åŒ–ç‚ºç™¾åˆ†æ¯”
                    const sumS = items.reduce((a, x) => a + Math.max(0, x.s), 0) || 1;
                    predictedAirportScores = items.map(x => ({ ap: x.ap, prob: Math.max(0, x.s)/sumS }));
                    predictedAirportScores.sort((a,b) => b.prob - a.prob);
                    let best = predictedAirportScores[0];
                    const forceNear = (closest && isFinite(minD) && minD <= nearKm);
                    if ((best && best.prob > 0.2) || forceNear) { // æ¥è¿‘æ™‚æ”¾å¯¬æ¢ä»¶
                        // é¡å¤–æ¢ä»¶ï¼šè‹¥è·é›¢å¾ˆé ä¸”è§’åº¦åå·®å¤§ï¼Œé¿å…ç›´æ¥å¸é™„ï¼ˆä»¥å…ã€Œèµ°éé ­å†æŠ˜è¿”ã€è¦–è¦ºï¼‰
                        const end = pathToDraw.length ? pathToDraw[pathToDraw.length-1] : last;
                        const pickAp = forceNear ? closest.ap : best.ap;
                        const dkm = haversineKm(end, pickAp);
                        const brAvg = avgBr;
                        const brToAp = bearingDeg(end, pickAp);
                        const dang = angleDiffDeg(brAvg, brToAp);
                        const okSnap = forceNear || (dkm <= 80) || (dang <= 45) || (best.prob >= 0.45);
                        if (okSnap) {
                            predictedNearestAirport = pickAp;
                            // è¿‘è·é›¢ä¸”è§’åº¦åˆç†æ™‚ï¼Œç›´æ¥èµ°ç›´ç·šåˆ°æ©Ÿå ´ï¼Œé¿å…è¿´æ—‹
                            const directMode = forceNear || ((dkm <= 60) && (dang <= 60 || best.prob >= 0.35));
                            if (directMode) {
                                pathToDraw = [ { lat: last.lat, lng: last.lng }, { lat: pickAp.lat, lng: pickAp.lng } ];
                            } else {
                                // ä¸€èˆ¬æƒ…æ³ï¼šä¿ç•™é æ¸¬ï¼Œè‹¥æœ«ç«¯è·é›¢æ©Ÿå ´ä»å¤§æ–¼ 2kmï¼Œè£œä¸€å€‹æ©Ÿå ´çµ‚é»é»
                                if (dkm > 2) pathToDraw.push({ lat: pickAp.lat, lng: pickAp.lng });
                            }
                            // ä¿å®ˆä¿®å‰ªï¼šå¦‚æœè·é›¢æ©Ÿå ´çš„åºåˆ—å‡ºç¾æ˜é¡¯å¢åŠ ï¼Œè£åˆ‡åˆ°é¦–æ¬¡å¢åŠ é»é¿å…ã€Œéé ­å†æŠ˜è¿”ã€
                            try {
                                if (pathToDraw && pathToDraw.length >= 3) {
                                    const ap = pickAp;
                                    let prev = haversineKm(pathToDraw[0], ap);
                                    let cut = -1;
                                    for (let i=1; i<pathToDraw.length; i++) {
                                        const d = haversineKm(pathToDraw[i], ap);
                                        if (d > prev + 1.0) { cut = i; break; }
                                        prev = d;
                                    }
                                    if (cut >= 0) {
                                        pathToDraw = pathToDraw.slice(0, cut);
                                        if (haversineKm(pathToDraw[pathToDraw.length-1], ap) > 2) {
                                            pathToDraw.push({ lat: ap.lat, lng: ap.lng });
                                        }
                                    }
                                }
                            } catch(_){}
                        }
                    }
                    // æ›´æ–°è©³ç´°é¢æ¿ï¼šé¡¯ç¤ºå‰ 5 å€‹æ©Ÿå ´çš„ç™¾åˆ†æ¯”
                    const destDetails = document.getElementById('destDetails');
                    if (destDetails && predictedAirportScores && predictedAirportScores.length) {
                        const topN = predictedAirportScores.slice(0, 5);
                        // æ¸…ç©ºèˆŠçš„ï¼ˆä¿ç•™ updateDestinationEstimates ç”Ÿæˆçš„éƒ¨åˆ†ä¹‹å‰ï¼Œæ’å…¥ä¸€æ®µæ©Ÿç‡åˆ—è¡¨ï¼‰
                        const block = document.createElement('li');
                        block.style.fontSize = '12px';
                        block.style.opacity = '0.95';
                        block.innerHTML = 'æ©Ÿå ´æ©Ÿç‡ï¼š' + topN.map(x => {
                            const label = (x.ap.iata||x.ap.icao||'UNK') + (x.ap.name?(' '+x.ap.name):'');
                            return `${label} ${(x.prob*100).toFixed(1)}%`;
                        }).join(' Â· ');
                        destDetails.prepend(block);
                    }
                }
            } catch (e) { console.warn('airport scoring failed', e); }
            const predictedPath = new google.maps.Polyline({
                path: pathToDraw,
                geodesic: false,
                strokeColor: '#ff6b6b',
                strokeOpacity: 1.0,
                strokeWeight: 4,
                icons: [{
                    icon: { path: google.maps.SymbolPath.FORWARD_CLOSED_ARROW, scale: 4, strokeColor: '#ff6b6b' },
                    offset: '100%'
                }]
            });
            predictedPath.setMap(map);
            // è®“æ¸…é™¤åŠŸèƒ½å¯ç§»é™¤é æ¸¬ç·š
            flightPaths.push(predictedPath);
            // æ›´æ–°é æ¸¬çµ‚é»æ¨™è¨˜ï¼ˆé»ƒè‰²ï¼‰ï¼Œç¢ºä¿èˆ‡è·¯å¾‘å°é½Š
            predictedLastPoint = pathToDraw[pathToDraw.length - 1] || null;
            if (destinationMarker) { destinationMarker.setMap(null); destinationMarker = null; }
            if (predictedLastPoint) {
                destinationMarker = new google.maps.Marker({
                    position: predictedLastPoint,
                    map: map,
                    icon: {
                        path: google.maps.SymbolPath.CIRCLE,
                        scale: 7,
                        fillColor: '#ffd54f',
                        fillOpacity: 0.95,
                        strokeWeight: 2,
                        strokeColor: '#000'
                    },
                    title: (() => {
                        if (!predictedNearestAirport) return `é æ¸¬çµ‚é» (${predictedLastPoint.lat.toFixed(3)}, ${predictedLastPoint.lng.toFixed(3)})`;
                        let pct = '';
                        if (predictedAirportScores && predictedAirportScores.length && predictedAirportScores[0].ap === predictedNearestAirport) {
                            pct = ` ${(predictedAirportScores[0].prob*100).toFixed(1)}%`;
                        }
                        return `é æ¸¬çµ‚é»ï¼ˆå°é½Šæ©Ÿå ´ ${predictedNearestAirport.iata||predictedNearestAirport.icao||''} ${predictedNearestAirport.name||''}${pct}ï¼‰`;
                    })()
                });
            }
            // åŒæ­¥æ‘˜è¦é¡¯ç¤º
            refreshDestinationSummary();
        }

        // é¡¯ç¤ºç›®å‰æ¼”ç®—æ³•çš„ Top 5 ç·šæ®µåˆ°åœ°åœ–ï¼ˆè‹¥å·²æœ‰çµæœï¼‰
        function showTopFiveNow() {
            let results = null;
            if (multiAlgorithmResults && multiAlgorithmResults[currentAlgorithm]) {
                results = multiAlgorithmResults[currentAlgorithm];
            } else if (predictionResults && predictionResults[currentAlgorithm] && predictionResults[currentAlgorithm].results) {
                results = predictionResults[currentAlgorithm].results;
            }
            if (!results || !results.length) {
                alert('ç›®å‰æ²’æœ‰å¯ç”¨çš„ Top 5 çµæœï¼Œè«‹å…ˆåŸ·è¡Œåˆ†æã€‚');
                return;
            }
            displaySimilarFlights(results);
            updateTopFiveList(results, currentAlgorithm);
        }

    // ï¼ˆå·²ç§»é™¤ï¼‰Top 1 çºŒèˆªç¤ºç¯„åŠŸèƒ½

        // è²è‘‰æ–¯å„ªåŒ–
        function runBayesianOptimization() {
            updateStatus('ğŸ§  å•Ÿå‹•è²è‘‰æ–¯å„ªåŒ–è‡ªå‹•èª¿åƒâ€¦');
            const btn = document.querySelector('.optimization-btn');
            const original = btn.textContent; btn.disabled = true; btn.textContent = 'ğŸ”„ å„ªåŒ–ä¸­â€¦';
            showProgress(true);
            startLocalETA(30, 'å„ªåŒ–åƒæ•¸');
            fetch('/api/optimize-parameters', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ n_calls: 30 })
            })
            .then(r => { if (!r.ok) throw new Error(`å„ªåŒ– API éŒ¯èª¤: ${r.status}`); return r.json(); })
            .then(res => {
                if (res.optimization_complete) {
                    updateStatus(`âœ… è²è‘‰æ–¯å„ªåŒ–å®Œæˆï¼Œæœ€ä½³åˆ†æ•¸: ${Number(res.best_score).toFixed(4)}`);
                    alert(`ğŸ‰ è²è‘‰æ–¯å„ªåŒ–å®Œæˆï¼\næœ€ä½³åˆ†æ•¸: ${Number(res.best_score).toFixed(4)}\nå„ªåŒ–è¼ªæ•¸: ${res.optimization_calls}`);
                } else {
                    updateStatus('âŒ è²è‘‰æ–¯å„ªåŒ–æœªå®Œæˆ');
                }
            })
            .catch(err => { updateStatus(`âŒ å„ªåŒ–å¤±æ•—: ${err.message}`); console.error(err); })
            .finally(() => { btn.disabled = false; btn.textContent = original; hideProgress(); });
        }

        function displaySimilarFlights(results) {
            // åƒ…æ¸…é™¤ä¸Šä¸€çµ„ Top5 è¦–è¦ºåŒ–ï¼Œä¸å½±éŸ¿å…¶ä»–å·²ç¹ªè£½çš„èˆªç·šæˆ–é æ¸¬
            if (currentTopFiveIds && currentTopFiveIds.length) {
                currentTopFiveIds.forEach(fid => {
                    if (topFivePolylineMap[fid]) { topFivePolylineMap[fid].setMap(null); delete topFivePolylineMap[fid]; }
                    if (topFiveStartMarkers[fid]) { topFiveStartMarkers[fid].setMap(null); delete topFiveStartMarkers[fid]; }
                });
                currentTopFiveIds = [];
                highlightedFlightId = null;
            }
            updateStatus(`ğŸ” é¡¯ç¤º ${results.length} å€‹ç›¸ä¼¼èˆªç­...`);
            // ç‚ºäº†åœ¨æ¨™è¨˜ä¸Šé¡¯ç¤ºç™¾åˆ†æ¯”ï¼Œå…ˆç”¨ Top-5 çš„ç›¸å°æ¬Šé‡ï¼ˆ1/scoreï¼‰ç¶“ softmax è½‰æ›
            const topK = Math.min(5, results.length);
            const scoresK = results.slice(0, topK).map(r => (Number(r.score)||0));
            const weights = weightsFromScores(scoresK);
            let sf = softmax(weights, 0.8);
            sf = emphasizePercents(sf);
            const idToPct = {};
            for (let i=0;i<topK;i++) {
                const fid = results[i].flight;
                const pct = Math.max(0, Math.min(100, (sf[i]||0)*100));
                idToPct[fid] = pct;
            }
            const colors = ['#ff4444', '#44ff44', '#4444ff', '#ffff44', '#ff44ff', '#44ffff', '#ff8844'];
            results.forEach((result, index) => {
                if (index >= 5) return; // åªé¡¯ç¤ºå‰5å€‹æœ€ç›¸ä¼¼çš„
                const flightId = result.flight;
                currentTopFiveIds.push(flightId);
                // å¾å¾Œç«¯ç²å–è©²èˆªç­çš„å®Œæ•´è·¯å¾‘ï¼ˆéœ€ç·¨ç¢¼é¿å…ç‰¹æ®Šå­—å…ƒå¤±æ•—ï¼‰
                fetch(`/api/flight/${encodeURIComponent(flightId)}`)
                    .then(response => response.json())
                    .then(flightData => {
                        if (flightData.coordinates && flightData.coordinates.length >= 2) {
                            const color = colors[index % colors.length];
                            const path = normalizePathCoords(flightData.coordinates);
                            // èˆªç·š
                            const poly = new google.maps.Polyline({
                                path: path,
                                geodesic: true,
                                strokeColor: color,
                                strokeOpacity: 0.85,
                                strokeWeight: 3
                            });
                            poly.setMap(map);
                            topFivePolylineMap[flightId] = poly;
                            // èµ·é»æ¨™è¨˜
                            const startMarker = new google.maps.Marker({
                                position: path[0],
                                map: map,
                                icon: {
                                    path: google.maps.SymbolPath.CIRCLE,
                                    scale: 8,
                                    fillColor: color,
                                    fillOpacity: 0.9,
                                    strokeWeight: 2,
                                    strokeColor: '#ffffff'
                                },
                                title: (() => {
                                    const pct = (idToPct[flightId] != null) ? idToPct[flightId].toFixed(1) + '%' : '';
                                    return `ç›¸ä¼¼èˆªç­: ${formatFlightName(flightId, flightData)}\nç›¸ä¼¼åº¦: ${pct}`;
                                })()
                            });
                            topFiveStartMarkers[flightId] = startMarker;
                        }
                    })
                    .catch(error => {
                        console.error(`ç„¡æ³•è¼‰å…¥èˆªç­ ${flightId}:`, error);
                    });
            });
        }

        function calculateRealAccuracy(results) {
            // åŸºæ–¼çœŸå¯¦ç›¸ä¼¼åº¦åˆ†æ•¸è¨ˆç®—æº–ç¢ºç‡
            if (!results || results.length === 0) return 0;
            
            const avgScore = results.reduce((sum, r) => sum + (100 - r.score), 0) / results.length;
            return Math.max(0, Math.min(100, avgScore));
        }

        function displayPrediction(predictionPath, algorithm) {
            const colors = {
                'dtw': '#ff4444', 'lcss': '#44ff44', 'euclidean': '#4444ff',
                'frechet': '#ff44ff', 'hausdorff': '#ffff44', 'edr': '#44ffff', 'erp': '#ff8844'
            };
            
            const predictionPolyline = new google.maps.Polyline({
                path: predictionPath,
                geodesic: true,
                strokeColor: colors[algorithm],
                strokeOpacity: 0.8,
                strokeWeight: 4
            });
            
            predictionPolyline.setMap(map);
            flightPaths.push(predictionPolyline);
            
            // çµ‚é»æ¨™è¨˜
            new google.maps.Marker({
                position: predictionPath[predictionPath.length - 1],
                map: map,
                icon: {
                    path: google.maps.SymbolPath.CIRCLE,
                    scale: 8,
                    fillColor: colors[algorithm],
                    fillOpacity: 0.8,
                    strokeWeight: 2,
                    strokeColor: '#ffffff'
                },
                title: `${getAlgorithmName(algorithm)} é æ¸¬çµ‚é»`
            });
        }

        function clearPredictions() {
            // æ¸…é™¤é æ¸¬è·¯ç·šï¼ˆä¿ç•™èˆªç­æ•¸æ“šï¼‰
            flightPaths.forEach(path => { path.setMap(null); });
            flightPaths = [];
            // ä¹Ÿæ¸…é™¤ç›®å‰ Top5 çš„èˆªç·šèˆ‡æ¨™è¨˜
            if (currentTopFiveIds && currentTopFiveIds.length) {
                currentTopFiveIds.forEach(fid => {
                    if (topFivePolylineMap[fid]) { topFivePolylineMap[fid].setMap(null); delete topFivePolylineMap[fid]; }
                    if (topFiveStartMarkers[fid]) { topFiveStartMarkers[fid].setMap(null); delete topFiveStartMarkers[fid]; }
                });
                currentTopFiveIds = [];
                highlightedFlightId = null;
            }
            // æ¸…ç©º Top5 æ¸…å–®å…§å®¹èˆ‡æ¨™ç±¤ï¼Œé¡¯ç¤ºç©ºç‹€æ…‹
            try {
                const list = document.getElementById('topFiveList');
                const empty = document.getElementById('topFiveEmpty');
                const label = document.getElementById('topFiveAlgoLabel');
                if (list) list.innerHTML = '';
                if (empty) empty.style.display = 'block';
                if (label) label.textContent = '(æ²’æœ‰çµæœ)';
            } catch (_) {}
            // é‡ç½®å¿«å–ï¼Œé¿å…èˆŠè³‡æ–™å†æ¬¡é¡¯ç¤º
            predictionResults = {};
            multiAlgorithmResults = {};
            updateStatus('ğŸ—‘ï¸ å·²æ¸…é™¤æ‰€æœ‰é æ¸¬çµæœ');
            // æ¸…é™¤çµ‚é»æ¨™è¨˜èˆ‡æ‘˜è¦
            if (destinationMarker) { destinationMarker.setMap(null); destinationMarker = null; }
            predictedLastPoint = null; weightedDestCenter = null;
            const destSummary = document.getElementById('destSummary');
            const destDetails = document.getElementById('destDetails');
            if (destSummary) destSummary.textContent = 'å°šæœªåˆ†æ';
            if (destDetails) destDetails.innerHTML = '';
        }

        function comparePredictions() {
            // åˆä½µå¤šä¾†æºçµæœï¼ˆå–®ä¸€æ¼”ç®—æ³•åˆ†æ + ä¸€æ¬¡è·‘ä¸ƒç¨®æ¼”ç®—æ³•ï¼‰
            const combined = {};
            if (multiAlgorithmResults) {
                Object.keys(multiAlgorithmResults).forEach(k => {
                    const kk = (k || '').toLowerCase();
                    const arr = multiAlgorithmResults[k] || [];
                    if (arr && arr.length) combined[kk] = { results: arr };
                });
            }
            if (predictionResults) {
                Object.keys(predictionResults).forEach(k => {
                    const kk = (k || '').toLowerCase();
                    const entry = predictionResults[k];
                    if (entry && Array.isArray(entry.results) && entry.results.length) combined[kk] = { results: entry.results };
                });
            }
            const keys = Object.keys(combined);
            if (!keys.length) { alert('âš ï¸ è«‹å…ˆåŸ·è¡Œä¸€äº›åˆ†æï¼'); return; }

            let comparison = `ğŸ“Š åˆ†æçµæœæ¯”è¼ƒ (å…± ${keys.length} å€‹æ¼”ç®—æ³•):\n\n`;
            keys.forEach(alg => {
                const arr = combined[alg].results || [];
                const resultCount = arr.length;
                const avgScore = resultCount ? (arr.reduce((s, r) => s + (Number(r.score) || 0), 0) / resultCount).toFixed(2) : 'N/A';
                comparison += `${getAlgorithmName(alg)}: æ‰¾åˆ° ${resultCount} å€‹ç›¸ä¼¼èˆªç­ï¼Œå¹³å‡åˆ†æ•¸: ${avgScore}\n`;
            });
            alert(comparison);
        }

    function getAlgorithmName(algorithm) {
            const names = {
                'dtw': 'DTW (å‹•æ…‹æ™‚é–“è¦æ•´)', 'lcss': 'LCSS ',
                'euclidean': 'Euclidean Distance', 'frechet': 'FrÃ©chet Distance',
        'hausdorff': 'Hausdorff Distance', 'edr': 'EDR ', 'erp': 'ERP ',
        'subseq_dtw': 'Subsequence DTW'
            };
            return names[algorithm] || algorithm;
        }

        // æ»‘å‹•æ¢äº‹ä»¶
        (function(){
            const slider = document.getElementById('flightCountSlider');
            if (slider) slider.addEventListener('input', updateSliderDisplay);
        })();

        // é»æ“Šè¦–çª—å¤–é—œé–‰modal
        window.onclick = function(event) {
            const modal = document.getElementById('algorithmModal');
            if (event.target === modal) {
                closeAlgorithmModal();
            }
        }
    </script>

    <script>
        // è·¯å¾‘å·¥å…·ï¼šåº§æ¨™æ­£è¦åŒ–/å»é™¤é‡è¤‡é»
        function toLatLng(p) {
            if (!p) return null;
            const lat = (p.lat != null) ? p.lat : p.latitude;
            const lng = (p.lng != null) ? p.lng : p.longitude;
            if (typeof lat !== 'number' || typeof lng !== 'number' || isNaN(lat) || isNaN(lng)) return null;
            return { lat, lng };
        }
        function normalizePathCoords(coords) {
            if (!coords) return [];
            const out = [];
            const flat = (node) => {
                if (!node) return;
                if (Array.isArray(node)) {
                    for (const v of node) flat(v);
                } else if (typeof node === 'object' && Array.isArray(node.coordinates)) {
                    flat(node.coordinates);
                } else if (typeof node === 'object') {
                    const p = toLatLng(node);
                    if (p) out.push(p);
                }
            };
            flat(coords);
            // å»é™¤ç›¸é„°é‡è¦†é»ï¼ˆ<10mï¼‰
            const dedup = [];
            for (let i = 0; i < out.length; i++) {
                if (i === 0) { dedup.push(out[i]); continue; }
                const prev = dedup[dedup.length - 1];
                const cur = out[i];
                if (haversineKm(prev, cur) < 0.01) continue;
                dedup.push(cur);
            }
            return dedup;
        }

        // æ©Ÿå ´ç´¢å¼•ï¼šå˜—è©¦è¼‰å…¥å¤–éƒ¨ JSONï¼Œæˆ– DAFIF .datï¼Œä¸è¡Œå‰‡ä½¿ç”¨å…§å»ºå°‘é‡æ¸…å–®
        function parseDafifDat(text) {
            try {
                const lines = (text||'').split(/\r?\n/).map(s => s.trim()).filter(Boolean);
                const out = [];
                for (const line of lines) {
                    // æ ¼å¼: CC,Name,ICAO,IATA,lon,lat,elev
                    const parts = line.split(',');
                    if (parts.length < 6) continue;
                    const cc = parts[0];
                    const name = parts[1];
                    const icao = parts[2];
                    const iata = parts[3] || '';
                    const lon = Number(parts[4]);
                    const lat = Number(parts[5]);
                    if (!isFinite(lat) || !isFinite(lon)) continue;
                    out.push({ iata: iata || undefined, icao: icao || undefined, name, lat, lng: lon });
                }
                return out;
            } catch (_) { return []; }
        }
        async function preloadAirports() {
            try {
                const tryPaths = ['/airports.json', '/data/airports.json', '/airports-dafif.json'];
                for (const p of tryPaths) {
                    try {
                        const r = await fetch(p);
                        if (r.ok) {
                            const j = await r.json();
                            if (Array.isArray(j) && j.length) { airportsIndex = j; updateStatus(`ğŸ—ºï¸ å·²è¼‰å…¥æ©Ÿå ´ç´¢å¼• (${j.length})`); return; }
                        }
                    } catch (_) {}
                }
                // å˜—è©¦ DAFIF ç´”æ–‡å­—æª”ï¼ˆå¤šç¨®å¯èƒ½è·¯å¾‘ï¼‰
                const dafifPaths = ['/airports-dafif.dat', 'airports-dafif.dat', '/data/airports-dafif.dat'];
                for (const p of dafifPaths) {
                    try {
                        const r2 = await fetch(p);
                        if (r2.ok) {
                            const txt = await r2.text();
                            const arr = parseDafifDat(txt);
                            if (arr.length) { airportsIndex = arr; updateStatus(`ğŸ—ºï¸ å·²è¼‰å…¥æ©Ÿå ´ç´¢å¼• (DAFIF ${arr.length})`); return; }
                        }
                    } catch (_) {}
                }
            } catch (_) {}
            airportsIndex = (typeof builtinAirports !== 'undefined' && Array.isArray(builtinAirports)) ? builtinAirports.slice() : [];
            if (airportsIndex.length) updateStatus('ğŸ—ºï¸ ä½¿ç”¨å…§å»ºæ©Ÿå ´æ¸…å–®ï¼ˆç¤ºä¾‹ï¼‰');
        }

        function findNearestAirport(point, maxKm = 300) {
            if (!point || !airportsIndex || !airportsIndex.length) return null;
            let best = null, bestD = Number.POSITIVE_INFINITY;
            for (const ap of airportsIndex) {
                const d = haversineKm(point, ap);
                if (d < bestD) { bestD = d; best = ap; }
            }
            if (!isFinite(bestD) || bestD > maxKm) return null;
            return best;
        }
    </script>

    <script async defer
        src="https://maps.googleapis.com/maps/api/js?key=AIzaSyB2rNDbGRGTVubn0aQw2NZP38UH_igS3LU&libraries=drawing&callback=initMap">
    </script>
</body>
</html>
